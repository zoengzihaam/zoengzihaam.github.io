<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zoengzihaam.github.io</id>
    <title>卷毛</title>
    <updated>2020-11-25T10:36:18.356Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zoengzihaam.github.io"/>
    <link rel="self" href="https://zoengzihaam.github.io/atom.xml"/>
    <subtitle>没有撤退可言。</subtitle>
    <logo>https://zoengzihaam.github.io/images/avatar.png</logo>
    <icon>https://zoengzihaam.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 卷毛</rights>
    <entry>
        <title type="html"><![CDATA[docker开机自启]]></title>
        <id>https://zoengzihaam.github.io/post/16/</id>
        <link href="https://zoengzihaam.github.io/post/16/">
        </link>
        <updated>2020-07-25T14:51:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="docker开机自启">docker开机自启</h1>
<h2 id="一-docker服务设置自动启动">一、docker服务设置自动启动</h2>
<blockquote>
<p>适用于yum安装的各种服务</p>
</blockquote>
<ul>
<li>查看已启动的服务</li>
</ul>
<pre><code class="language-shell">systemctl list-units --type=service
</code></pre>
<ul>
<li>查看是否设置开机启动</li>
</ul>
<pre><code class="language-shell">systemctl list-unit-files | grep enable
</code></pre>
<ul>
<li>设置开机启动</li>
</ul>
<pre><code class="language-shell">systemctl enable docker.service
</code></pre>
<ul>
<li>关闭开机启动</li>
</ul>
<pre><code class="language-shell">systemctl disable docker.service
</code></pre>
<h2 id="二-docker容器设置自动启动">二、docker容器设置自动启动</h2>
<ul>
<li>启动时加 --restart=always</li>
</ul>
<pre><code class="language-shell">docker run tomcat -it -d -p 8080:8080 --restart=always
</code></pre>
<ul>
<li>
<p>如果已经运行过的项目</p>
<p>针对：已经启动的项目，使用update更新</p>
</li>
</ul>
<pre><code class="language-shell">docker update --restart=always imagesID
</code></pre>
<p><strong>restart参数的启动选项</strong></p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>no</td>
<td>不自动重启容器. (默认value)</td>
</tr>
<tr>
<td>on-failure</td>
<td>容器发生error而退出(容器退出状态不为0)重启容器</td>
</tr>
<tr>
<td>unless-stopped</td>
<td>在容器已经stop掉或Docker stoped/restarted的时候才重启容器</td>
</tr>
<tr>
<td>always</td>
<td>在容器已经stop掉或Docker stoped/restarted的时候才重启容器</td>
</tr>
</tbody>
</table>
<hr>
<p>转载至：<a href="https://www.cnblogs.com/gcgc/p/10494615.html#_label0">秋寻草</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker安装GUI图形化界面（Portainer）]]></title>
        <id>https://zoengzihaam.github.io/post/15/</id>
        <link href="https://zoengzihaam.github.io/post/15/">
        </link>
        <updated>2020-07-25T13:21:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="docker安装gui图形化界面portainer">Docker安装GUI图形化界面（Portainer）</h1>
<blockquote>
<p>Portainer是一个开源、轻量级Docker管理用户界面，基于Docker API，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型单位对容器管理的全部需求。</p>
</blockquote>
<h2 id="快速入门">快速入门</h2>
<h3 id="1官网">1.官网</h3>
<p>https://www.portainer.io/installation/</p>
<h3 id="2使用docker安装portainer">2.使用docker安装portainer</h3>
<h4 id="1搜索portainer">1.搜索portainer</h4>
<pre><code class="language-visual">docker search portainer
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200725205726.png" alt="image-20200725205725916" loading="lazy"></figure>
<h4 id="2将镜像拉取到本地">2.将镜像拉取到本地</h4>
<pre><code class="language-visual">docker pull portainer/portainer
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200725205825.png" alt="image-20200725205824991" loading="lazy"></figure>
<h4 id="3运行镜像">3.运行镜像</h4>
<pre><code class="language-vi">docker run -d -it --name portainerUI -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200725205900.png" alt="image-20200725205900786" loading="lazy"></figure>
<p>注意：这里如果使用单机版，一定要使用 <code>-v /var/run/docker.sock:/var/run/docker.sock</code>，否则在进入WEBUI的时候创建会出现问题，这里 <code>volume</code>也可使用官方教程，这里将运行代码一并贴入。</p>
<pre><code class="language-visual">docker volume create portainer_data
docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer
</code></pre>
<p>官方这里创建了一个portainer_data的文件夹用于存储数据，大家按需运行即可。</p>
<h3 id="3访问portainer">3.访问Portainer</h3>
<h4 id="1创建用户">1.创建用户</h4>
<p>打开浏览器输入 <code>ip:端口号</code>，这里ip是Linux的地址，端口号为启动的时候映射的端口。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200725211127.png" alt="image-20200725211127863" loading="lazy"></figure>
<h4 id="2连接docker环境">2.连接docker环境</h4>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200725211700.png" alt="image-20200725211700177" loading="lazy"></figure>
<h4 id="3进入portainer管理">3.进入Portainer管理</h4>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200725211815.png" alt="image-20200725211815704" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GateWay自定义全局GlobalFilter]]></title>
        <id>https://zoengzihaam.github.io/post/13/</id>
        <link href="https://zoengzihaam.github.io/post/13/">
        </link>
        <updated>2020-07-06T11:14:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="gateway自定义全局globalfilter">GateWay自定义全局GlobalFilter</h1>
<h2 id="1实现两个接口">1.实现两个接口</h2>
<ul>
<li>
<p>GlobalFilter</p>
<p>用于自定义过滤器，例如进行Token验证</p>
</li>
<li>
<p>Ordered</p>
<p>Spring提供了Ordered这个接口，来处理相同接口实现类的优先级问题。</p>
</li>
</ul>
<pre><code class="language-Java">import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.Date;

@Component
@Slf4j
public class MyLogGateWayFilter implements GlobalFilter, Ordered {

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {

        //打印输出信息
        log.info(&quot;************come in MyLogGateWayFilter&quot; + new Date());

        //获取request中的参数
        String name = exchange.getRequest().getQueryParams().getFirst(&quot;name&quot;);
        //判断参数的信息
        if(name ==null){
            log.info(&quot;************用户名为null，非法用户，/(ㄒoㄒ)/~~&quot;);
            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);
            return exchange.getResponse().setComplete();
        }

        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return 0;
    }
}
</code></pre>
<h2 id="2-使用cmd验证">2. 使用CMD验证</h2>
<ul>
<li>
<p>遵循过滤器中的规则</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706185828.png" alt="image-20200706185828629" loading="lazy"></figure>
</li>
<li>
<p>不遵循过滤器中的规则</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706185856.png" alt="image-20200706185856027" loading="lazy"></figure>
</li>
</ul>
<h2 id="3网页端测试">3.网页端测试</h2>
<ul>
<li>
<p>遵循过滤器中的规则</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706185952.png" alt="image-20200706185952065" loading="lazy"></figure>
</li>
<li>
<p>不遵循过滤器中的规则</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706190016.png" alt="image-20200706190016823" loading="lazy"></figure>
</li>
</ul>
<p>结论：自定义Filter类似SpringMVC中的Filter，GlobalGilter 全局过滤器接口与 GatewayFilter 网关过滤器接口具有相同的方法定义。全局过滤器是一系列特殊的过滤器，会根据条件应用到所有路由中。网关过滤器是更细粒度的过滤器，作用于指定的路由中。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微服务中使用GateWay实现保护、增强和控制对于 API 服务的访问。]]></title>
        <id>https://zoengzihaam.github.io/post/12/</id>
        <link href="https://zoengzihaam.github.io/post/12/">
        </link>
        <updated>2020-07-06T09:16:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="微服务中使用gateway实现保护-增强和控制对于-api-服务的访问">微服务中使用GateWay实现保护、增强和控制对于 API 服务的访问。</h1>
<blockquote>
<p>网关的角色是作为一个 API 架构，用来保护、增强和控制对于 API 服务的访问。</p>
<p>API 网关是一个处于应用程序或服务（提供 REST API 接口服务）之前的系统，用来管理授权、访问控制和流量限制等，这样 REST API 接口服务就被 API 网关保护起来，对所有的调用者透明。因此，隐藏在 API 网关后面的业务系统就可以专注于创建和管理服务，而不用去处理这些策略性的基础设施。</p>
</blockquote>
<h2 id="简单使用">简单使用</h2>
<h3 id="三个概念">三个概念</h3>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706150913.png" alt="image-20200706150913342" loading="lazy"></figure>
<p>注：上图引用CSDN博主<a href="https://blog.csdn.net/rain_web/article/details/102469745">AlgoRain</a>，这里致谢一下大佬详细的讲解。</p>
<h3 id="springcloud中使用">springcloud中使用</h3>
<h4 id="1新建module">1.新建Module</h4>
<p>添加一个新的Module，cloud-gateway-gateway9527（名称按照自己喜好）</p>
<h4 id="2添加pom依赖">2.添加POM依赖</h4>
<pre><code class="language-Java">&lt;dependencies&gt;
        &lt;!--gateway--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--Eureka client--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--导入自己定义的api通用包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.ziznah.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;${project.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--一般基础配置类--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h4 id="3添加yml文件">3.添加YML文件</h4>
<pre><code class="language-yaml">#配置端口
server:
  port: 9527

spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      routes:
        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001          #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**         # 断言，路径相匹配的进行路由

        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001          #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
#注册进服务中心，这里使用的是eureka
eureka:
  instance:
    hostname: cloud-gateway-service
  client: #服务提供者provider注册进eureka服务列表内
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://localhost:7001/eureka/

</code></pre>
<h4 id="4主启动类">4.主启动类</h4>
<pre><code class="language-Java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
@EnableDiscoveryClient
public class GateWayMain9527 {
    public static void main(String[] args) {
        SpringApplication.run(GateWayMain9527.class,args);
    }
}
</code></pre>
<h4 id="使用配置类来简单使用gateway">使用配置类来简单使用GateWay</h4>
<ul>
<li>将http://localhost:9527/guonei转发到百度的新闻网中的国内信息</li>
</ul>
<pre><code class="language-java">import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GateWayConfig {

    /**
     * 配置一个id为route-name的路由规则，
     * 当访问地址http://localhost:9527/guonei时会自动转发到地址：http://news.baidu.com/guonei
     * @param routeLocatorBuilder
     * @return
     */
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder){
        //获取网关的routes
        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();
        //设置网关的内容
        routes.route(&quot;path_route_ziznah&quot;,r -&gt; r.path(&quot;/guonei&quot;).uri(&quot;http://news.baidu.com/guonei&quot;)).build();

        //返回内容
        return routes.build();
    }
}
</code></pre>
<h4 id="实现动态路由">实现动态路由</h4>
<ul>
<li>多个服务提供者进行提供服务，使用动态路由来到达负载均衡</li>
</ul>
<h5 id="1yml">1.YML</h5>
<pre><code class="language-yaml">server:
  port: 9527

spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
     #开启动态创建路由的功能
      discovery:
        locator:
          enabled: true   #开启从注册中心动态创建路由的功能，利用微服务名进行路由
      routes:
        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
#          uri: http://localhost:8001          #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service   #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**         # 断言，路径相匹配的进行路由

        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
#          uri: http://localhost:8001          #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service   #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由

eureka:
  instance:
    hostname: cloud-gateway-service
  client: #服务提供者provider注册进eureka服务列表内
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://localhost:7001/eureka/
</code></pre>
<p>注：需要注意的是uri的协议lb，表示启用Gateway的负载均衡功能，lb://serverName是spring cloud  gatway在微服务中自动为我们创建的负载均衡uri。</p>
<h3 id="predicates断言不同类型">predicates断言不同类型</h3>
<h4 id="1after">1.After</h4>
<ul>
<li>YML文件</li>
</ul>
<pre><code class="language-yaml"># 断言，路径相匹配的进行路由
predicates:		
	- After=2020-07-06T16:43:08.146+08:00[Asia/Shanghai]
</code></pre>
<p>上述的时间地址可使用Java中time的api来获取：</p>
<pre><code class="language-java">import java.time.ZoneId;
import java.time.ZonedDateTime;

public class T2 {
    public static void main(String[] args) {
        //获取默认时区
        ZonedDateTime zdt = ZonedDateTime.now();
        System.out.println(zdt);
        //通过指定时区获取当前时间
        ZonedDateTime now = ZonedDateTime.now(ZoneId.of(&quot;America/New_York&quot;));
        System.out.println(now);
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706164619.png" alt="image-20200706164619481" loading="lazy"></figure>
<h4 id="2before">2.Before</h4>
<p>方法同After</p>
<h4 id="3between">3.Between</h4>
<p>方法同After</p>
<h4 id="4cookie">4.Cookie</h4>
<ul>
<li>YML文件</li>
</ul>
<pre><code class="language-yaml"># 断言，路径相匹配的进行路由
predicates:		
	- Cookie=ceshi,admin	
</code></pre>
<p>Windows中CMD窗口使用curl命令进行http请求</p>
<ul>
<li>不带Cookie进行访问测试。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706165615.png" alt="image-20200706165615728" loading="lazy"></figure>
<ul>
<li>带Cookie进行访问测试。</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706165741.png" alt="image-20200706165741593" loading="lazy"></figure>
<h4 id="5header">5.Header</h4>
<ul>
<li>YML文件</li>
</ul>
<pre><code class="language-yaml"># 断言，路径相匹配的进行路由
predicates:		
	- Header=X-Request-Id, \d+		#请求头要有X-Request-Id属性，并且值为正数的正则表达式。
</code></pre>
<p>使用CMD的curl命令测试</p>
<ul>
<li>带Header</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706170541.png" alt="image-20200706170541704" loading="lazy"></figure>
<ul>
<li>
<p>不带Header</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706170608.png" alt="image-20200706170608051" loading="lazy"></figure>
</li>
<li>
<p>带错误的Header信息</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706170644.png" alt="image-20200706170644528" loading="lazy"></figure>
</li>
</ul>
<h4 id="6host">6.Host</h4>
<ul>
<li>YML</li>
</ul>
<pre><code class="language-yaml"># 断言，路径相匹配的进行路由
predicates:		
	- Host=**.ceshi.com
</code></pre>
<p>使用CMD的curl命令测试</p>
<ul>
<li>
<p>带Host测试</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706171138.png" alt="image-20200706171138672" loading="lazy"></figure>
</li>
<li>
<p>不带Host测试</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706171300.png" alt="image-20200706171300046" loading="lazy"></figure>
</li>
<li>
<p>带错误Host测试</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200706171234.png" alt="image-20200706171234897" loading="lazy"></figure>
</li>
</ul>
<h4 id="7method">7.Method</h4>
<ul>
<li>YML</li>
</ul>
<pre><code class="language-yaml"># 断言，路径相匹配的进行路由
predicates:		
	- Method=GET
</code></pre>
<h4 id="8path">8.Path</h4>
<h4 id="9query">9.Query</h4>
<h4 id="10weight">10.Weight</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[参考RoundRobinRule代码模拟负载均衡]]></title>
        <id>https://zoengzihaam.github.io/post/11/</id>
        <link href="https://zoengzihaam.github.io/post/11/">
        </link>
        <updated>2020-06-25T10:12:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="参考roundrobinrule代码模拟负载均衡">参考RoundRobinRule代码模拟负载均衡</h1>
<h2 id="1定义一个loadbalancer接口">1.定义一个LoadBalancer接口</h2>
<ul>
<li>获取服务器集群上能够提供服务的机器数量</li>
</ul>
<pre><code class="language-java">public interface Loadbalancer {
    /**
     * 获取服务器集群上能够提供服务的机器数量
     * @param serviceInstances
     * @return
     */
    ServiceInstance instances(List&lt;ServiceInstance&gt; serviceInstances);
}
</code></pre>
<h2 id="2实现loadbalancer接口中的方法">2.实现LoadBalancer接口中的方法</h2>
<ul>
<li>利用自旋锁，创建获取当前服务调用是第几次访问的方法</li>
<li>实现接口中获取提供服务机器数量的方法，模拟负载均衡算法来达到负载调用服务。</li>
</ul>
<pre><code class="language-java">/**
 * ClassName: MyLB
 * Description: 参考RoundRobinRule代码模拟负载均衡
 * Author: SUGAR
 * Date: 2020/6/25 16:09
 * Version: 1.0
 **/
@Component
public class MyLB implements Loadbalancer{

    private AtomicInteger atomicInteger = new AtomicInteger(0);

    /**
     * 获取当前服务调用是第几次访问
     * @return
     */
    public final int getAndIncrement(){
        int current;
        int next;

        do {
            current = this.atomicInteger.get();
            next = current &gt;= 2147483647 ? 0 : current + 1;
        }while (!this.atomicInteger.compareAndSet(current,next));
        System.out.println(&quot;*****访问第&quot; + next + &quot;次！*****&quot;);
        return next;
    }

    /**
     * 根据第几次访问，模拟负载均衡算法来达到负载调用服务
     * 负载均衡算法：rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标
     * 每次服务启动后rest接口计数从1开始
     * @param serviceInstances
     * @return
     */
    @Override
    public ServiceInstance instances(List&lt;ServiceInstance&gt; serviceInstances) {

        int index = getAndIncrement() % serviceInstances.size();

        return serviceInstances.get(index);
    }
}
</code></pre>
<h2 id="3取消loadbalanced注解">3.取消LoadBalanced注解</h2>
<ul>
<li>取消ApplicationContextConfig中RestTemplate的get方法的LoadBalanced注解，使用自己模拟的负载均衡。</li>
</ul>
<pre><code class="language-java">@Configuration
public class ApplicationContextConfig {

    @Bean
//    @LoadBalanced 使用自己模拟的负载均衡的方法
    public RestTemplate getRestTemplate(){
        return new RestTemplate();
    }
}
</code></pre>
<h2 id="4添加服务提供商提供的controller方法">4.添加服务提供商提供的controller方法</h2>
<ul>
<li>添加一个获取当前服务提供者端口的方法，用来负载均衡。</li>
</ul>
<pre><code class="language-java">@GetMapping(value = &quot;/payment/lb&quot;)
public String getPaymentLB() {
    return serverPort;
}
</code></pre>
<p><font style="color:red"><strong>注：</strong></font>这里的方法添加到提供商的controller中。</p>
<h2 id="5调用者添加controller方法">5.调用者添加controller方法</h2>
<ul>
<li>调用者controller添加调用服务提供商的方法，测试负载均衡</li>
</ul>
<pre><code class="language-java">@GetMapping(value = &quot;/consumer/payment/lb&quot;)
public String getPayementLB(){
    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);
    //判断服务是否为有效服务
    if(instances == null || instances.size() &lt;= 0){
        return null;
    }

    ServiceInstance serviceInstance = loadbalancer.instances(instances);
    URI uri = serviceInstance.getUri();

    return restTemplate.getForObject(uri + &quot;/payment/lb&quot;,String.class);
}
</code></pre>
<h2 id="6测试">6.测试</h2>
<ul>
<li>启动对应的服务</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200625175834.png" alt="image-20200625175834663" loading="lazy"></figure>
<ul>
<li>查看是否启动成功（模拟提供者集群以及服务器集群）</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200625180016.png" alt="image-20200625180016280" loading="lazy"></figure>
<ul>
<li>模拟调用者访问接口</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200625180207.png" alt="image-20200625180207309" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200625180221.png" alt="image-20200625180221054" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200625180244.png" alt="image-20200625180244048" loading="lazy"></figure>
<p>​	根据以上调用，后台也打印出相应的调用信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker中 CMD 与 ENTRYPOINT 保留指令的区别]]></title>
        <id>https://zoengzihaam.github.io/post/10/</id>
        <link href="https://zoengzihaam.github.io/post/10/">
        </link>
        <updated>2020-06-09T13:52:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>编写Dockerfile时，时常看到最后会看到CMD或者ENTRYPOINT 的保留指令，但是他们的意义都为：指定一个容器启动时要运行的命令，那么它们之间的差异在哪里？</p>
</blockquote>
<h2 id="使用curl命令来说明">使用curl命令来说明</h2>
<h3 id="首先编写两个dockerfile">首先编写两个Dockerfile</h3>
<ol>
<li>使用<code>CMD</code>保留指令。</li>
</ol>
<pre><code class="language-shell">FROM centos
RUN yum install -y curl
CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;https://www.baidu.com/&quot; ]
</code></pre>
<p>这里 Dockerfile 的名字要求小写，否则会报错<code>invalid argument &quot;cmdCentos&quot; for &quot;-t, --tag&quot; flag: invalid reference format: repository name must be lowercase See 'docker build --help'.</code></p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609213217.png" alt="image-20200609213217668" loading="lazy"></figure>
<ol start="2">
<li>使用<code>ENTRYPOINT</code>保留指令。</li>
</ol>
<pre><code class="language-shell">FROM centos
RUN yum install -y curl
ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;https://www.baidu.com/&quot; ]
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609213320.png" alt="image-20200609213320960" loading="lazy"></figure>
<h3 id="在docker中进行build进行构建一个新的镜像">在docker中进行build进行构建一个新的镜像</h3>
<ol>
<li>
<p>构建<code>CMD</code>保留指令的Dockerfile。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609213449.png" alt="image-20200609213449579" loading="lazy"></figure>
</li>
<li>
<p>构建<code>ENTRYPOINT</code>保留指令的Dockerfile。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609213554.png" alt="image-20200609213553986" loading="lazy"></figure>
</li>
</ol>
<h3 id="运行两个镜像进行对比">运行两个镜像进行对比</h3>
<ol>
<li>
<p>运行<code>CMD</code>保留指令的镜像。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609213732.png" alt="image-20200609213732383" loading="lazy"></figure>
</li>
<li>
<p>运行<code>ENTRYPOINT</code>保留指令的镜像。</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609213855.png" alt="image-20200609213855288" loading="lazy"></figure>
</li>
</ol>
<p>这个时候我们发现，两个镜像运行起来没有任何区别，但是<strong>重点来了</strong>！当我们需要<strong>对镜像启动时要运行的命令进行增强</strong>的时候。</p>
<p>比如我们还想获取指定网站的<code>头信息</code>。</p>
<ol start="3">
<li>
<p>运行增强后的<code>CMD</code>保留指令的镜像。</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609214241.png" alt="image-20200609214241092" loading="lazy"></figure>
</li>
<li>
<p>运行增强后的<code>ENTRYPOINT</code>保留指令的镜像。</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609214443.png" alt="image-20200609214443164" loading="lazy"></figure>
</li>
</ol>
<h3 id="总结">总结</h3>
<p>由上述的案例，我们不难发现，在执行Dockerfile中，如果使用了<code>CMD</code>保留指令，那么在执行镜像的时候，我们在其启动命令后面添加<code>OPTION</code>选项的时候，将会覆盖Dockerfile中的上一句指令，造成运行失败。例如：</p>
<pre><code class="language-shell">FROM centos
RUN yum install -y curl
CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;https://www.baidu.com/&quot; ]
CMD -i
</code></pre>
<p>如果使用<code>ENTRYPOINT</code>保留指令，那么在执行镜像的时候，我们在其启动命令后面添加<code>OPTION</code>选项的时候，会对运行的命令进行<code>“增强”</code>。例如：</p>
<pre><code class="language-shell">FROM centos
RUN yum install -y curl
ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;,&quot;-i&quot;, &quot;https://www.baidu.com/&quot; ]
</code></pre>
<p>所以，在实际应用中，是使用<code>CMD</code>还是<code>ENTRYPOINT</code>保留指令，要根据具体的业务要求。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在VMware Workstation上安装CentOS7的网络问题]]></title>
        <id>https://zoengzihaam.github.io/post/9/</id>
        <link href="https://zoengzihaam.github.io/post/9/">
        </link>
        <updated>2020-06-09T06:20:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="配置网络">配置网络</h2>
<h3 id="虚拟机centos的网络设置">虚拟机CentOS的网络设置</h3>
<h4 id="1-将网络适配器设置为nat模式">1. 将网络适配器设置为<code>NAT模式</code></h4>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609140748.png" alt="image-20200609140748138" loading="lazy"></figure>
<h4 id="2-linux中网络设置">2. Linux中网络设置</h4>
<p><code>cd /etc/sysconfig/network-scripts/</code>，进入CentOS7的网络配置文件下，找到对应的网卡设置，我这里的网卡是<code>ifcfg-ens32</code>，每个人的网卡名称可能不一样，不用在意。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609141501.png" alt="image-20200609141501373" loading="lazy"></figure>
<p><code>vim ifcfg-ens32</code> ，打开指定的网卡配置文件，如果系统没有安装 vim，使用 vi 打开即可。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609141842.png" alt="image-20200609141842892" loading="lazy"></figure>
<p>添加的<code>ip</code>、<code>子网掩码</code>、<code>网关</code>，在VMware Workstation中的虚拟网络编辑器中查看。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609142048.png" alt="image-20200609142048076" loading="lazy"></figure>
<p>选择<code>VMnet8</code>，然后<code>NAT设置</code></p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609142226.png" alt="image-20200609142226380" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200609142259.png" alt="image-20200609142259233" loading="lazy"></figure>
<p><strong>IPADDR</strong>：为上方的子网IP，建议IP设置为<code>XXX.XXX.XXX.200~XXX.XXX.XXX.250</code>之间</p>
<p><strong>PREFIXO</strong>：为上方子网掩码，255.255.255.0即为24</p>
<p><strong>GATEWAY</strong>：为上方网关IP，对应填上即可。</p>
<p><strong>DNS1</strong>：8.8.8.8</p>
<p><strong>DNS2</strong>：8.8.4.4</p>
<p>这里DNS都设置为谷歌的DNS，正常解析即可，其他DNS也可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis]]></title>
        <id>https://zoengzihaam.github.io/post/8/</id>
        <link href="https://zoengzihaam.github.io/post/8/">
        </link>
        <updated>2020-06-04T12:10:36.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>多能，数据类型丰富，使用Redis，Tair</p>
<p>Redis:REmote DIctionary Server(远程字典服务器)</p>
<p>是完全开源免费的，用C语言编写的，遵守BSD协议，<br>
是一个高性能的(key/value)分布式内存数据库，基于内存运行<br>
并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,<br>
也被人们称为数据结构服务器</p>
</blockquote>
<h2 id="下载redis">下载Redis</h2>
<p>https://redis.io/download</p>
<h2 id="对redis的理解">对Redis的理解</h2>
<ol>
<li>Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。</li>
<li>KV、Cache、Persistence、...</li>
</ol>
<h2 id="redis的概述">Redis的概述</h2>
<ul>
<li><strong>3V+3高</strong></li>
</ul>
<table>
<thead>
<tr>
<th>3V</th>
<th>3高</th>
</tr>
</thead>
<tbody>
<tr>
<td>海量Volume</td>
<td>高并发</td>
</tr>
<tr>
<td>多样Variety</td>
<td>高可扩</td>
</tr>
<tr>
<td>实时Velocity</td>
<td>高性能</td>
</tr>
</tbody>
</table>
<h2 id="传统关系型数据库">传统关系型数据库</h2>
<p><strong>传统的ACID</strong></p>
<h3 id="1-a-atomicity-原子性">1、A (Atomicity) 原子性</h3>
<p>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</p>
<h3 id="2-c-consistency-一致性">2、C (Consistency) 一致性</h3>
<p>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。</p>
<h3 id="3-i-isolation-独立性">3、I (Isolation) 独立性</h3>
<p>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的</p>
<h3 id="4-d-durability-持久性">4、D (Durability) 持久性</h3>
<p>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</p>
<h2 id="非关系型数据库">非关系型数据库</h2>
<p><strong>CAP</strong></p>
<h3 id="cconsistency强一致性">C:Consistency（强一致性）</h3>
<h3 id="aavailability可用性">A:Availability（可用性）</h3>
<h3 id="ppartition-tolerance分区容错性">P:Partition tolerance（分区容错性）</h3>
<h2 id="redis的安装">Redis的安装</h2>
<blockquote>
<p>Linux版安装</p>
</blockquote>
<ul>
<li>
<p>获取<code>Redis</code>的安装包</p>
<p>将安装包放在/usr/local/redis下</p>
</li>
<li>
<p>解压<code>Redis</code>安装包</p>
</li>
</ul>
<pre><code class="language-shell">tar -zxvf redis-5.0.4.tar.gz
</code></pre>
<ul>
<li>进入Redis目录</li>
</ul>
<pre><code class="language-shell">cd /usr/local/redis/redis-5.0.4
</code></pre>
<ul>
<li>执行<code>make</code>命令</li>
</ul>
<pre><code class="language-shell">make
</code></pre>
<p><font color=red>运行make命令时故<br>
意出现的错误解析：</font></p>
<p>​	安装gcc</p>
<pre><code class="language-shell">yum -y install gcc-c++
</code></pre>
<ul>
<li>执行<code>make install</code>，检验安装</li>
</ul>
<pre><code class="language-shell">make install
</code></pre>
<h2 id="redis基本使用">Redis基本使用</h2>
<h3 id="更改配置">更改配置</h3>
<h4 id="1更改redisconf配置文件">1.更改redis.conf配置文件</h4>
<p>首先备份当前<code>redis.conf</code>文件，修改以下内容。</p>
<pre><code class="language-shell">daemonize yes
</code></pre>
<h3 id="启动">启动</h3>
<p>安装<code>redis</code>之后，在<code>/usr/local/bin</code>会有redis的启动文件。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509140808.png" alt="image-20200509140806730" loading="lazy"></figure>
<ul>
<li>执行<code>redis-server /bak/redis/redis.conf</code>，启动redis并使用指定的配置文件。</li>
</ul>
<pre><code class="language-shell">redis-server /bak/redis/redis.conf
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509140947.png" alt="image-20200509140946468" loading="lazy"></figure>
<h3 id="连通测试">连通测试</h3>
<ul>
<li>执行<code>redis-cli -p 6379</code>来指定端口启动测试。</li>
</ul>
<pre><code class="language-shell">redis-cli -p 6379
</code></pre>
<ul>
<li>使用<code>ping</code>命令来测试连通，出现<code>PONG</code>即为成功。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509141352.png" alt="image-20200509141350989" loading="lazy"></figure>
<ul>
<li>可使用ps -ef|grep redis来查看redis的进程。</li>
</ul>
<pre><code class="language-shell">ps -ef|grep redis
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509141627.png" alt="image-20200509141626567" loading="lazy"></figure>
<h3 id="关闭redis">关闭redis</h3>
<ul>
<li>执行<code>redis-cli shutdown</code>。</li>
</ul>
<pre><code class="language-shell">redis-cli shutdown
</code></pre>
<h2 id="redis可能遇到问题">Redis可能遇到问题</h2>
<ul>
<li><strong>修改配置文件</strong></li>
</ul>
<pre><code class="language-shell">protected-mode no # 关闭保护模式
daemonize yes     # 守护进程模式开启
#bind 127.0.0.1   # 绑定IP按需修改
port 6379         # 端口按需修改
</code></pre>
<ul>
<li><strong>运行并检查端口</strong></li>
</ul>
<pre><code class="language-shell">#启动服务命令
./usr/local/bin/redis-server /bak/redis/redis.conf
#查看6379端口是否占用
netstat -tunpl | grep 6379
</code></pre>
<ul>
<li><strong>开放防火墙端口</strong></li>
</ul>
<pre><code class="language-shell">#开放6379端口
/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT
#保存配置
/etc/rc.d/init.d/iptables save
#重启服务
/etc/rc.d/init.d/iptables restart
#查看端口是否已经开放
/etc/init.d/iptables status
</code></pre>
<h2 id="redis启动后杂项基础知识讲解">Redis启动后杂项基础知识讲解</h2>
<h3 id="单进程">单进程</h3>
<blockquote>
<p>单进程模型来处理客户端的请求。对读写等事件的响应<br>
是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率</p>
</blockquote>
<blockquote>
<p>Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，<br>
它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>
</blockquote>
<h3 id="默认16个数据库">默认16个数据库</h3>
<ul>
<li>
<p>默认16个数据库，类似数组下表从零开始，初始默认使用零号库。</p>
<p>可以使用<code>select &lt;id&gt;</code>来连接指定数据库id</p>
</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509145022.png" alt="image-20200509145021853" loading="lazy"></figure>
<h3 id="dbsize">DBSIZE</h3>
<ul>
<li>Dbsize查看当前数据库的key的数量</li>
</ul>
<pre><code class="language-shell">DBSIZE
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509145149.png" alt="image-20200509145148783" loading="lazy"></figure>
<ul>
<li>使用<code>keys *</code>可查看当前库中的key</li>
</ul>
<pre><code class="language-shell">keys *
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509145301.png" alt="image-20200509145300027" loading="lazy"></figure>
<h3 id="flushdb"><strong>FLUSHDB</strong></h3>
<ul>
<li>清空当前库</li>
</ul>
<pre><code class="language-shell">FLUSHDB
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509145519.png" alt="image-20200509145518458" loading="lazy"></figure>
<h3 id="flushall">FLUSHALL</h3>
<ul>
<li>通杀全部库</li>
</ul>
<pre><code class="language-shell">FLUSHALL
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509145941.png" alt="image-20200509145940266" loading="lazy"></figure>
<h3 id="统一密码管理">统一密码管理</h3>
<h3 id="索引">索引</h3>
<ul>
<li>Reids索引都是从零开始</li>
</ul>
<h3 id="默认端口">默认端口</h3>
<ul>
<li>默认端口是6379</li>
</ul>
<h2 id="redis数据类型">Redis数据类型</h2>
<h3 id="redis的五大数据类型">Redis的五大数据类型</h3>
<h4 id="string字符串">String（字符串）</h4>
<p>String（字符串）</p>
<p>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</p>
<h4 id="hash哈希类似java里的map">Hash（哈希，类似java里的Map）</h4>
<p>Hash（哈希）<br>
Redis hash 是一个键值对集合。<br>
Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>类似Java里面的Map&lt;String,Object&gt;</p>
<h4 id="list列表">List（列表）</h4>
<p>List（列表）<br>
Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。<br>
它的底层实际是个链表</p>
<h4 id="set集合">Set（集合）</h4>
<p>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的。</p>
<h4 id="zsetsorted-set有序集合">Zset(sorted set：有序集合)</h4>
<p>zset(sorted set：有序集合)<br>
Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>
不同的是每个元素都会关联一个double类型的分数。<br>
redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>
<h3 id="哪里去获得redis常见数据类型操作命令">哪里去获得redis常见数据类型操作命令</h3>
<ul>
<li>Http://redisdoc.com/</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509163322.png" alt="image-20200509163320729" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509150946.png" alt="image-20200509150945470" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509163404.png" alt="image-20200509163403248" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509163452.png" alt="image-20200509163445728" loading="lazy"></figure>
<h3 id="redis-键key">Redis 键(key)</h3>
<ul>
<li><strong>常用</strong></li>
</ul>
<figure data-type="image" tabindex="14"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509164137.png" alt="image-20200509164136826" loading="lazy"></figure>
<ul>
<li>
<p><strong>案例</strong></p>
<ul>
<li><code>keys *</code></li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509164723.png" alt="image-20200509164721746" loading="lazy"></figure>
<ul>
<li><code>exists key</code>的名字，判断某个key是否存在。</li>
</ul>
<figure data-type="image" tabindex="16"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509164759.png" alt="image-20200509164758524" loading="lazy"></figure>
<ul>
<li><code>move key db</code>，移动当前库的key到指定的库中。</li>
</ul>
<figure data-type="image" tabindex="17"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509164846.png" alt="image-20200509164845216" loading="lazy"></figure>
<ul>
<li><code>expire key</code>，给指定的key设置一个过期时间。</li>
</ul>
<figure data-type="image" tabindex="18"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509165816.png" alt="image-20200509165815934" loading="lazy"></figure>
<ul>
<li><code>ttl key</code>，查看当前key的过期时间，-1表示永不过期，-2表示已过期。</li>
</ul>
<p>当key过期的时候，代表当前key的生命周期已经结束，所以在当前库中就不存在这个key。</p>
<figure data-type="image" tabindex="19"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509165609.png" alt="image-20200509165607432" loading="lazy"></figure>
<ul>
<li><code>type key</code>，查看当前的key的类型。</li>
</ul>
<figure data-type="image" tabindex="20"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509171236.png" alt="image-20200509171235161" loading="lazy"></figure>
<ul>
<li><code>del key</code>，删除当前的key</li>
</ul>
<figure data-type="image" tabindex="21"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509171824.png" alt="image-20200509171823453" loading="lazy"></figure>
</li>
</ul>
<h3 id="redis字符串string">Redis字符串(String)</h3>
<ul>
<li><strong>常用</strong></li>
</ul>
<figure data-type="image" tabindex="22"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509163741.png" alt="image-20200509163740370" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509163758.png" alt="image-20200509163757223" loading="lazy"></figure>
<ul>
<li>
<p><strong>单值单value</strong></p>
</li>
<li>
<p><strong>案例</strong></p>
<ul>
<li><code>set key value</code>，设置一个K,V</li>
</ul>
<figure data-type="image" tabindex="24"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509172150.png" alt="image-20200509172149069" loading="lazy"></figure>
<ul>
<li><code>get key</code>，获取当前key的value值。</li>
</ul>
<figure data-type="image" tabindex="25"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509172214.png" alt="image-20200509172212935" loading="lazy"></figure>
<ul>
<li><code>append key value</code>，在指定key的value值后添加指定的值。</li>
</ul>
<figure data-type="image" tabindex="26"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509172309.png" alt="image-20200509172308003" loading="lazy"></figure>
<ul>
<li><code>strlen key</code>，查询当前key的长度。</li>
</ul>
<figure data-type="image" tabindex="27"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509172350.png" alt="image-20200509172348777" loading="lazy"></figure>
<ul>
<li><code>incr key</code>，对当前的key进行递增。</li>
</ul>
<figure data-type="image" tabindex="28"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509172909.png" alt="image-20200509172908900" loading="lazy"></figure>
<ul>
<li><code>decr key</code>，对当前的key进行递减。</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="29"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509173003.png" alt="image-20200509173003082" loading="lazy"></figure>
<p><code>incrby key num</code>，对当前的key进行指定数字的递增。</p>
<figure data-type="image" tabindex="30"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509173838.png" alt="image-20200509173837831" loading="lazy"></figure>
<p><code>decrby key num</code>，对当前的key进行指定数字的递减。</p>
<figure data-type="image" tabindex="31"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509173919.png" alt="image-20200509173918434" loading="lazy"></figure>
<p>**注意：**一定要是数字才能进行加减。</p>
<p><code>getrange key start end</code>，获取当前key字符串的指定长度内容。</p>
<figure data-type="image" tabindex="32"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509174324.png" alt="image-20200509174323706" loading="lazy"></figure>
<p><code>setrange key index str</code>，设置当前key字符串指定下标开始，设置str内容。</p>
<figure data-type="image" tabindex="33"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509174716.png" alt="image-20200509174714625" loading="lazy"></figure>
<p><code>setex key second value</code>setex(set with expire)，设置K,V，并设置到期时间。</p>
<figure data-type="image" tabindex="34"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509175112.png" alt="image-20200509175111603" loading="lazy"></figure>
<p><code>setnx key value</code>，setnx(set if not exist)，只有当前key不存在的时候，设置key的值。</p>
<figure data-type="image" tabindex="35"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509175337.png" alt="image-20200509175336269" loading="lazy"></figure>
<p><code>mset key1 value1 key2 value2 key3 value3</code>，设置多个K,V。</p>
<figure data-type="image" tabindex="36"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509175550.png" alt="image-20200509175549643" loading="lazy"></figure>
<p><code>mget key1 key2 key3</code>，获取多个指定key的值。</p>
<figure data-type="image" tabindex="37"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509175651.png" alt="image-20200509175650583" loading="lazy"></figure>
<p><code>msetnx key1 value1 key2 value2 key3 value3</code>，设置多个值，当设置key不存在时，设置指定key值，如果一个不存在，则都不设置。</p>
<figure data-type="image" tabindex="38"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200511174045.png" alt="" loading="lazy"></figure>
<h3 id="redis列表list">Redis列表(List)</h3>
<ul>
<li>常用</li>
</ul>
<figure data-type="image" tabindex="39"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200511175624.png" alt="image-20200511175622928" loading="lazy"></figure>
<figure data-type="image" tabindex="40"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200511175638.png" alt="image-20200511175637169" loading="lazy"></figure>
<ul>
<li>
<p>单值多value</p>
</li>
<li>
<p>案例</p>
<ul>
<li><code>lpush key value1 [value2]</code>，将一个或多个值插入到列表头部。</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="41"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200512213854.png" alt="image-20200512213850399" loading="lazy"></figure>
<p><code>rpush key value1 [value2]</code>，在列表中添加一个或多个值</p>
<figure data-type="image" tabindex="42"><img src="D:%5C%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Credis%5Cupload%5Cimage-20200512214133456.png" alt="image-20200512214133456" loading="lazy"></figure>
<p><code>lrange key start end</code>，获取列表指定范围内的元素</p>
<figure data-type="image" tabindex="43"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200512214536.png" alt="image-20200512214535408" loading="lazy"></figure>
<p><code>lpop key</code>，移除并获取列表的第一个元素</p>
<figure data-type="image" tabindex="44"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200512215656.png" alt="image-20200512215655300" loading="lazy"></figure>
<p><code>rpop key</code>，移除并获取列表最后一个元素。</p>
<figure data-type="image" tabindex="45"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200513121600.png" alt="image-20200513121559312" loading="lazy"></figure>
<p><code>lindex key index</code>，根据下标，查询执行列表中的数据。</p>
<figure data-type="image" tabindex="46"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200513122104.png" alt="image-20200513122102884" loading="lazy"></figure>
<p><code>llen key</code>，查询指定列表的长度</p>
<figure data-type="image" tabindex="47"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200513122214.png" alt="image-20200513122213323" loading="lazy"></figure>
<p><code>lrem key count value</code>，移除指定列表指定数量的值。</p>
<figure data-type="image" tabindex="48"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200513122536.png" alt="image-20200513122535830" loading="lazy"></figure>
<p><code>ltrim key start end</code>，截取指定列表的指定下标内容，然后赋值给这个列表。</p>
<figure data-type="image" tabindex="49"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200513123043.png" alt="image-20200513123000885" loading="lazy"></figure>
<p><code>rpoplpush source destination</code>，移除列表的最后一个元素，并将该元素添加到另一个列表并返回。</p>
<figure data-type="image" tabindex="50"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518171755.png" alt="image-20200518170936054" loading="lazy"></figure>
<p><code>lset key index value</code>，通过索引设置列表元素的值。</p>
<figure data-type="image" tabindex="51"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518172222.png" alt="image-20200518172221911" loading="lazy"></figure>
<p><code>linsert key before|after pivot value</code>，在列表的元素前或者后插入元素。</p>
<figure data-type="image" tabindex="52"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518172734.png" alt="image-20200518172733735" loading="lazy"></figure>
<h3 id="redis集合set">Redis集合(Set)</h3>
<ul>
<li>常用</li>
</ul>
<figure data-type="image" tabindex="53"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518173358.png" alt="image-20200518173357120" loading="lazy"></figure>
<ul>
<li>
<p>单值多value</p>
</li>
<li>
<p>案例</p>
<ul>
<li><code>sadd key member1 [member2]</code>，向集合添加一个或多个成员。</li>
</ul>
<figure data-type="image" tabindex="54"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518173952.png" alt="image-20200518173848658" loading="lazy"></figure>
<ul>
<li><code>smembers key</code>，返回集合中的所有成员</li>
</ul>
<figure data-type="image" tabindex="55"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518174145.png" alt="image-20200518174144650" loading="lazy"></figure>
<ul>
<li><code>sismember key member</code>，判断 member 元素是否是集合key的成员。</li>
</ul>
<figure data-type="image" tabindex="56"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518174329.png" alt="image-20200518174328349" loading="lazy"></figure>
<ul>
<li><code>scard key</code>，获取集合的成员数</li>
</ul>
<figure data-type="image" tabindex="57"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518174531.png" alt="image-20200518174530718" loading="lazy"></figure>
<ul>
<li><code>srem key member1 [member2]</code>，移除集合中一个或多个成员</li>
</ul>
<figure data-type="image" tabindex="58"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518174653.png" alt="image-20200518174652704" loading="lazy"></figure>
<ul>
<li><code>srandmember key [count]</code>，返回集合中一个或多个随机数。</li>
</ul>
<figure data-type="image" tabindex="59"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518174943.png" alt="image-20200518174941232" loading="lazy"></figure>
<ul>
<li><code>spop key</code>，移除并返回集合中的一个随机元素</li>
</ul>
<figure data-type="image" tabindex="60"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518175932.png" alt="image-20200518175930355" loading="lazy"></figure>
<ul>
<li><code>smove key1 key2 member</code>，将member元素从key1集合移动到key2集合。</li>
</ul>
<figure data-type="image" tabindex="61"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519221958.png" alt="image-20200519221957915" loading="lazy"></figure>
<ul>
<li>
<p>数学集合类</p>
<ul>
<li><code>sdiff key1 [key2]</code>，返回给定所有集合的差集。（在第一个set里面而不在后面任何一个set里面的项）</li>
</ul>
<figure data-type="image" tabindex="62"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519222408.png" alt="image-20200519222407399" loading="lazy"></figure>
<ul>
<li><code>sinter key1 [key2]</code>，返回给定所有集合的交集。</li>
</ul>
<figure data-type="image" tabindex="63"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519222629.png" alt="image-20200519222628138" loading="lazy"></figure>
<ul>
<li><code>sunion key1 [key2]</code>，返回所有给定集合的并集。</li>
</ul>
<figure data-type="image" tabindex="64"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519222823.png" alt="image-20200519222822998" loading="lazy"></figure>
</li>
</ul>
</li>
</ul>
<h3 id="redis哈希hash">Redis哈希(Hash)</h3>
<ul>
<li>常用</li>
</ul>
<figure data-type="image" tabindex="65"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519223109.png" alt="image-20200519223106752" loading="lazy"></figure>
<ul>
<li>
<p>KV模式不变，但V是一个键值对。</p>
</li>
<li>
<p>案例</p>
<ul>
<li><code>hset key field value</code>，将哈希表key中 的字段field的值设为value。</li>
</ul>
<figure data-type="image" tabindex="66"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519223639.png" alt="image-20200519223620338" loading="lazy"></figure>
<ul>
<li><code>hget key field</code>，获取存储在哈希表中指定field字段的值。</li>
</ul>
<figure data-type="image" tabindex="67"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519223621.png" alt="image-20200519223620338" loading="lazy"></figure>
<ul>
<li><code>hmset key field1 value1 [field2 value2]</code>，同时将多个field-value(域-值)对设置到哈希表key中。</li>
</ul>
<figure data-type="image" tabindex="68"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519224026.png" alt="image-20200519224025622" loading="lazy"></figure>
<ul>
<li><code>hgetall key</code>，获得存储在哈希表中指定key的所有字段和值。</li>
</ul>
<figure data-type="image" tabindex="69"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519224211.png" alt="image-20200519224210926" loading="lazy"></figure>
<ul>
<li><code>hdel key field</code>，删除存储在哈希表中key 指定字段。</li>
</ul>
<figure data-type="image" tabindex="70"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519224352.png" alt="image-20200519224351205" loading="lazy"></figure>
<ul>
<li><code>hexists key field</code>，查询存储在哈希表中指定字段是否存在</li>
</ul>
<figure data-type="image" tabindex="71"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519224931.png" alt="image-20200519224930651" loading="lazy"></figure>
<ul>
<li><code>hkeys key</code>，获取所有哈希表中的字段</li>
</ul>
<figure data-type="image" tabindex="72"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519225102.png" alt="image-20200519225101378" loading="lazy"></figure>
<ul>
<li><code>hvals keys</code>，获取哈希表中所有的值。</li>
</ul>
<figure data-type="image" tabindex="73"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519225150.png" alt="image-20200519225149340" loading="lazy"></figure>
<ul>
<li><code>hincrby key field increment</code>，为哈希表key中的指定字段的整数值加上增量increment。</li>
</ul>
<figure data-type="image" tabindex="74"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519225443.png" alt="image-20200519225442220" loading="lazy"></figure>
<ul>
<li><code>hincrbyfloat key field increment</code>，为哈希表中的指定字段的浮点数值加上增量increment。</li>
</ul>
<figure data-type="image" tabindex="75"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519225615.png" alt="image-20200519225614338" loading="lazy"></figure>
<ul>
<li><code>hsetnx key field value</code>，只有在字段field不存在时，设置哈希表字段的值。</li>
</ul>
<figure data-type="image" tabindex="76"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519225935.png" alt="image-20200519225934654" loading="lazy"></figure>
</li>
</ul>
<h3 id="redis有序集合zsetsorted-set">Redis有序集合Zset(sorted set)</h3>
<ul>
<li>常用</li>
</ul>
<figure data-type="image" tabindex="77"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521150248.png" alt="image-20200521150246364" loading="lazy"></figure>
<figure data-type="image" tabindex="78"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521151239.png" alt="image-20200521151229536" loading="lazy"></figure>
<ul>
<li>
<p>案例</p>
<ul>
<li><code>zadd key score1 member1 [score2 member2]</code>，向有序集合添加一个或多个成员，或者更新已存在成员的分数。</li>
</ul>
<figure data-type="image" tabindex="79"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521151041.png" alt="image-20200521151040926" loading="lazy"></figure>
<ul>
<li><code>zrangebyscore key start end</code>，通过分数返回有序集合指定区间内的成员。</li>
</ul>
<figure data-type="image" tabindex="80"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521152441.png" alt="image-20200521152440530" loading="lazy"></figure>
<ul>
<li><code>zrangebyscore key (start end</code>，通过返回有序集合指定区间内(带有<code>(</code>，说明不包含)的成员。</li>
</ul>
<figure data-type="image" tabindex="81"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521160141.png" alt="image-20200521160140065" loading="lazy"></figure>
<ul>
<li><code>zrem key member</code>，根据对应的value值删除有序集合中的成员元素。</li>
</ul>
<figure data-type="image" tabindex="82"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521160744.png" alt="image-20200521160743971" loading="lazy"></figure>
<ul>
<li><code>zcard key</code>，获得有序列表中的成员数。</li>
</ul>
<figure data-type="image" tabindex="83"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521163302.png" alt="image-20200521163301419" loading="lazy"></figure>
<ul>
<li><code>zcount key min max</code>，查询在有序列表中指定区间的成员数。</li>
</ul>
<figure data-type="image" tabindex="84"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521163434.png" alt="image-20200521163426648" loading="lazy"></figure>
<ul>
<li><code>zrank key value</code>，获取指定成员在有序列表中的下标。</li>
</ul>
<figure data-type="image" tabindex="85"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521163702.png" alt="image-20200521163701613" loading="lazy"></figure>
<ul>
<li><code>zscore key value</code>，获取有序列表中指定成员的值。</li>
</ul>
<figure data-type="image" tabindex="86"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521163813.png" alt="image-20200521163813036" loading="lazy"></figure>
<ul>
<li><code>zrevrank key values</code>，逆序获得下标值。</li>
</ul>
<figure data-type="image" tabindex="87"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521163956.png" alt="image-20200521163955191" loading="lazy"></figure>
</li>
</ul>
<h2 id="解析配置文件redisconf">解析配置文件redis.conf</h2>
<h3 id="1它在哪">1.它在哪</h3>
<ul>
<li>
<p>地址。</p>
<p>进入redis目录下，使用<code>pwd</code>命令来查看当前目录。</p>
</li>
</ul>
<figure data-type="image" tabindex="88"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521165404.png" alt="image-20200521165403592" loading="lazy"></figure>
<ul>
<li>
<p>为什么拷贝出来单独执行？</p>
<p>通常为了配置的安全，放置在原文件配置错误，导致无法正常运行。</p>
</li>
</ul>
<h3 id="2units单位">2.Units单位</h3>
<figure data-type="image" tabindex="89"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521165629.png" alt="image-20200521165628558" loading="lazy"></figure>
<h3 id="3includes包含">3.INCLUDES包含</h3>
<ul>
<li>和其他配置文件一样，可以通过includes包含，redis.conf可以作为总闸，包含其他。</li>
</ul>
<figure data-type="image" tabindex="90"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521170957.png" alt="image-20200521170956374" loading="lazy"></figure>
<h3 id="4general通用">4.GENERAL通用</h3>
<h4 id="daemonize">daemonize</h4>
<ul>
<li>介绍
<ul>
<li>A、redis.conf配置文件中daemonize守护线程，默认是NO。</li>
<li>B、daemonize是用来指定redis是否要用守护线程的方式启动。</li>
</ul>
</li>
<li>daemonize 设置yes或者no区别
<ul>
<li><code>daemonize:yes</code>:redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。</li>
<li><code>daemonize:no</code>: 当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。</li>
</ul>
</li>
</ul>
<h4 id="pidfile">Pidfile</h4>
<ul>
<li>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定。</li>
</ul>
<h4 id="port">Port</h4>
<ul>
<li>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字。</li>
</ul>
<h4 id="tcp-backlog">Tcp-backlog</h4>
<ul>
<li>
<p>文档解释</p>
<p>tcp-backlog<br>
设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。<br>
在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值来达到想要的效果。</p>
</li>
</ul>
<h4 id="timeout">Timeout</h4>
<ul>
<li>当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能。</li>
</ul>
<h4 id="bind">Bind</h4>
<ul>
<li>绑定的主机地址</li>
</ul>
<h4 id="tcp-keepalive">Tcp-keepalive</h4>
<ul>
<li>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60。</li>
</ul>
<h4 id="loglevel">Loglevel</h4>
<ul>
<li>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice</li>
</ul>
<h4 id="logfile">Logfile</h4>
<ul>
<li>指定日志文件的路径。</li>
</ul>
<h4 id="syslog-enabled">Syslog-enabled</h4>
<ul>
<li>是否把日志输出到syslog中。默认是no。</li>
</ul>
<h4 id="syslog-ident">Syslog-ident</h4>
<ul>
<li>指定syslog里的日志标志。默认是redis。</li>
</ul>
<h4 id="syslog-facility">Syslog-facility</h4>
<ul>
<li>指定syslog设备，值可以是USER或LOCAL0-LOCAL7。默认是LOCAL0。</li>
</ul>
<h4 id="databases">Databases</h4>
<ul>
<li>设置数据库的数量，默认数量为16，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id。</li>
</ul>
<h3 id="5snapshotting快照">5.SNAPSHOTTING快照</h3>
<h4 id="save">Save</h4>
<ul>
<li>save 秒钟 写操作次数</li>
</ul>
<p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，<br>
默认<br>
是1分钟内改了1万次，<br>
或5分钟内改了10次，<br>
或15分钟内改了1次。</p>
<figure data-type="image" tabindex="91"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525102515.png" alt="image-20200525102515280" loading="lazy"></figure>
<ul>
<li>禁用</li>
</ul>
<p>如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。</p>
<figure data-type="image" tabindex="92"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525102536.png" alt="image-20200525102536487" loading="lazy"></figure>
<ul>
<li>如果想即可备份，使用<code>save</code>命令，可执行立即备份功能。</li>
</ul>
<h4 id="stop-writes-on-bgsave-error">Stop-writes-on-bgsave-error</h4>
<p>如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制。</p>
<figure data-type="image" tabindex="93"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525102558.png" alt="image-20200525102558301" loading="lazy"></figure>
<h4 id="rdbcompression">rdbcompression</h4>
<p>rdbcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用<br>
LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能</p>
<h4 id="rdbchecksum">rdbchecksum</h4>
<h4 id="dbfilename">dbfilename</h4>
<h4 id="dir">dir</h4>
<h3 id="6replication复制">6.REPLICATION复制</h3>
<h3 id="7security安全">7.SECURITY安全</h3>
<ul>
<li>访问密码的查看、设置和取消。</li>
</ul>
<figure data-type="image" tabindex="94"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521173800.png" alt="image-20200521173759042" loading="lazy"></figure>
<h3 id="8limits限制">8.LIMITS限制</h3>
<h4 id="maxclients">Maxclients</h4>
<ul>
<li>设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当你<br>
无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自<br>
身内部处理逻辑留一些句柄出来。如果达到了此限制，redis则会拒绝新的连接请求，并且向这<br>
些连接请求方发出“max number of clients reached”以作回应。</li>
</ul>
<h4 id="maxmemory">Maxmemory</h4>
<ul>
<li>
<p>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，<br>
那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</p>
<p>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>
</li>
</ul>
<h4 id="maxmemory-policy">Maxmemory-policy</h4>
<ul>
<li>（1）volatile-lru：使用LRU算法移除key，只对设置了过期时间的键。</li>
<li>（2）allkeys-lru：使用LRU算法移除key。</li>
<li>（3）volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键。</li>
<li>（4）allkeys-random：移除随机的key。</li>
<li>（5）volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key。</li>
<li>（6）noeviction：不进行移除。针对写操作，只是返回错误信息。</li>
</ul>
<h4 id="maxmemory-samples">Maxmemory-samples</h4>
<ul>
<li>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，<br>
redis默认会检查这么多个key并选择其中LRU的那个。</li>
</ul>
<h3 id="9append-only-mode追加">9.APPEND ONLY MODE追加</h3>
<h4 id="appendonly">appendonly</h4>
<h4 id="appendfilename">appendfilename</h4>
<h4 id="appendfsync">Appendfsync</h4>
<figure data-type="image" tabindex="95"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525210259.png" alt="image-20200525210259806" loading="lazy"></figure>
<ul>
<li>Always：同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好。</li>
<li>Everysec：出厂默认推荐，异步操作，每秒记录   如果一秒内宕机，有数据丢失。</li>
<li>No</li>
</ul>
<h4 id="no-appendfsync-on-rewrite重写时是否可以运用appendfsync用默认no即可保证数据安全性">No-appendfsync-on-rewrite：重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。</h4>
<h4 id="auto-aof-rewrite-min-size设置重写的基准值">Auto-aof-rewrite-min-size：设置重写的基准值</h4>
<h4 id="auto-aof-rewrite-percentage设置重写的基准值">Auto-aof-rewrite-percentage：设置重写的基准值</h4>
<h2 id="redis的持久化">Redis的持久化</h2>
<h3 id="总体介绍">总体介绍</h3>
<h4 id="官网介绍">官网介绍</h4>
<figure data-type="image" tabindex="96"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200524221645.png" alt="image-20200524221645176" loading="lazy"></figure>
<h3 id="rdbredis-database">RDB（Redis DataBase）</h3>
<h4 id="官网介绍-2">官网介绍</h4>
<figure data-type="image" tabindex="97"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200524221834.png" alt="image-20200524221834175" loading="lazy"></figure>
<h4 id="是什么">是什么：</h4>
<ul>
<li>在指定的时间间隔内将内存中的数据集快照写入磁盘，<br>
也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</li>
<li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到<br>
一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。<br>
整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能<br>
如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方<br>
式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</li>
</ul>
<h4 id="fork">Fork</h4>
<ul>
<li>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）<br>
数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</li>
</ul>
<h4 id="rdb-保存的是dumprdb文件">Rdb 保存的是dump.rdb文件</h4>
<h4 id="配置位置">配置位置</h4>
<figure data-type="image" tabindex="98"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200524223800.png" alt="image-20200524223800247" loading="lazy"></figure>
<h4 id="如何触发rdb快照">如何触发RDB快照</h4>
<h5 id="配置文件中默认的快照配置">配置文件中默认的快照配置</h5>
<figure data-type="image" tabindex="99"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525104217.png" alt="image-20200525104217106" loading="lazy"></figure>
<ul>
<li>
<p>冷拷贝后重新使用</p>
<p>可以cp dump.rdb dump_new.rdb</p>
</li>
</ul>
<h5 id="命令save或者是bgsave">命令save或者是bgsave</h5>
<ul>
<li>Save：save时只管保存，其它不管，全部阻塞</li>
</ul>
<figure data-type="image" tabindex="100"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525104534.png" alt="image-20200525104534717" loading="lazy"></figure>
<ul>
<li>BGSAVE：Redis会在后台异步进行快照操作，<br>
快照同时还可以响应客户端请求。可以通过lastsave<br>
命令获取最后一次成功执行快照的时间</li>
</ul>
<h5 id="执行flushall命令也会产生dumprdb文件但里面是空的无意义">执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</h5>
<h4 id="如何恢复">如何恢复</h4>
<ul>
<li>
<p>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</p>
</li>
<li>
<p>CONFIG GET dir获取目录</p>
</li>
</ul>
<h4 id="优势">优势</h4>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
</ul>
<h4 id="劣势">劣势</h4>
<ul>
<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就<br>
会丢失最后一次快照后的所有修改</li>
<li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
</ul>
<h4 id="如何停止">如何停止</h4>
<ul>
<li>动态所有停止RDB保存规则的方法：redis-cli config set save &quot;&quot;</li>
</ul>
<h4 id="小总结">小总结</h4>
<figure data-type="image" tabindex="101"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525105545.png" alt="image-20200525105545632" loading="lazy"></figure>
<h3 id="aofappend-only-file">AOF（Append Only File）</h3>
<h4 id="官网介绍-3">官网介绍</h4>
<figure data-type="image" tabindex="102"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525110108.png" alt="image-20200525110108706" loading="lazy"></figure>
<h4 id="是什么-2">是什么：</h4>
<blockquote>
<p><strong>以日志的形式来记录每个写操作</strong>，将Redis执行过的所有写指令记录下来(读操作不记录)，<br>
只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
</blockquote>
<h4 id="aof保存的是appendonlyaof文件">Aof保存的是appendonly.aof文件</h4>
<h4 id="配置位置-2">配置位置</h4>
<figure data-type="image" tabindex="103"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525205831.png" alt="image-20200525205831351" loading="lazy"></figure>
<h4 id="aof启动修复恢复">AOF启动/修复/恢复</h4>
<h5 id="正常恢复">正常恢复</h5>
<ul>
<li>启动：设置Yes</li>
<li>修改默认的appendonly no，改为yes</li>
<li>将有数据的aof文件复制一份保存到对应目录(config get dir)。</li>
<li>恢复：重启redis然后重新加载。</li>
</ul>
<h5 id="异常恢复">异常恢复</h5>
<ul>
<li>启动：设置Yes</li>
<li>修改默认的appendonly no，改为yes。</li>
<li>备份被写坏的AOF文件</li>
<li>修复：Redis-check-aof --fix进行修复</li>
<li>恢复：重启redis然后重新加载</li>
</ul>
<h4 id="rewrite">Rewrite</h4>
<figure data-type="image" tabindex="104"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525212540.png" alt="image-20200525212540047" loading="lazy"></figure>
<h5 id="是什么-3">是什么：</h5>
<blockquote>
<p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,<br>
当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，<br>
只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p>
</blockquote>
<h5 id="重写原理">重写原理</h5>
<p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，<br>
遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，<br>
而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。</p>
<h5 id="触发机制">触发机制</h5>
<p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。</p>
<h4 id="优势-2">优势</h4>
<h5 id="每修改同步">每修改同步：</h5>
<p>appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好。</p>
<h5 id="每秒同步">每秒同步：</h5>
<p>appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失</p>
<h5 id="不同步">不同步：</h5>
<p>appendfsync no   从不同步。</p>
<h4 id="劣势-2">劣势</h4>
<ol>
<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb。</li>
<li>Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同。</li>
</ol>
<h4 id="小总结-2">小总结</h4>
<figure data-type="image" tabindex="105"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525212854.png" alt="image-20200525212854369" loading="lazy"></figure>
<h3 id="总结which-one">总结(Which one)</h3>
<h4 id="官网建议">官网建议</h4>
<figure data-type="image" tabindex="106"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525212951.png" alt="image-20200525212951704" loading="lazy"></figure>
<ol>
<li>
<p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。</p>
</li>
<li>
<p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些<br>
命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.<br>
Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。</p>
</li>
<li>
<p>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式。</p>
</li>
<li>
<p>同时开启两种持久化方式。</p>
<ul>
<li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,<br>
因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？<br>
作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，<br>
快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li>
</ul>
</li>
<li>
<p>性能建议。</p>
<ul>
<li>
<p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</p>
<p>如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</p>
<p>如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构。</p>
</li>
</ul>
</li>
</ol>
<h2 id="redis的事务">Redis的事务</h2>
<h3 id="是什么-4">是什么</h3>
<blockquote>
<p>可以一次执行多个命令，本质是一组命令的集合。一个事务中的<br>
所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞。</p>
</blockquote>
<ul>
<li>官网</li>
</ul>
<figure data-type="image" tabindex="107"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095415.png" alt="image-20200526095415167" loading="lazy"></figure>
<h3 id="能干嘛">能干嘛</h3>
<ul>
<li>一个队列中，一次性、顺序性、排他性的执行一系列命令。</li>
</ul>
<h3 id="怎么玩">怎么玩</h3>
<figure data-type="image" tabindex="108"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095448.png" alt="image-20200526095448303" loading="lazy"></figure>
<h4 id="常用命令">常用命令</h4>
<figure data-type="image" tabindex="109"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095615.png" alt="image-20200526095615512" loading="lazy"></figure>
<h4 id="case1正常执行">Case1：正常执行</h4>
<figure data-type="image" tabindex="110"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095635.png" alt="image-20200526095635884" loading="lazy"></figure>
<h4 id="case2放弃事务">Case2：放弃事务</h4>
<figure data-type="image" tabindex="111"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095644.png" alt="image-20200526095644734" loading="lazy"></figure>
<h4 id="case3全体连坐">Case3：全体连坐</h4>
<figure data-type="image" tabindex="112"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095652.png" alt="image-20200526095652384" loading="lazy"></figure>
<h4 id="case4冤头债主">Case4：冤头债主</h4>
<figure data-type="image" tabindex="113"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095701.png" alt="image-20200526095701700" loading="lazy"></figure>
<h4 id="case5watch监控">Case5：watch监控</h4>
<ol>
<li>
<p>悲观锁/乐观锁/CAS(Check And Set)</p>
<ul>
<li>
<p>悲观锁</p>
<p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
</li>
<li>
<p>乐观锁</p>
<p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，</p>
<p>乐观锁策略:提交版本必须大于记录当前版本才能执行更新。</p>
</li>
<li>
<p>CAS</p>
</li>
</ul>
</li>
<li>
<p>初始化信用卡可用余额和欠额</p>
<figure data-type="image" tabindex="114"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526100000.png" alt="image-20200526095959959" loading="lazy"></figure>
</li>
<li>
<p>无加塞篡改，先监控再开启multi，保证两笔金额变动在同一个事务内。</p>
<figure data-type="image" tabindex="115"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526100012.png" alt="image-20200526100012139" loading="lazy"></figure>
</li>
<li>
<p>有加塞篡改。</p>
<figure data-type="image" tabindex="116"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526100020.png" alt="image-20200526100020441" loading="lazy"></figure>
</li>
<li>
<p>unwatch</p>
<figure data-type="image" tabindex="117"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526100028.png" alt="image-20200526100028027" loading="lazy"></figure>
</li>
<li>
<p>一旦执行了exec之前加的监控锁都会被取消掉了</p>
</li>
<li>
<p>小结</p>
<ul>
<li>Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变，<br>
比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行。</li>
<li>通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，<br>
EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</li>
</ul>
</li>
</ol>
<h3 id="3阶段">3阶段</h3>
<h4 id="开启">开启：</h4>
<p>以MULTI开始一个事务。</p>
<h4 id="入队">入队：</h4>
<p>将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</p>
<h4 id="执行">执行：</h4>
<p>由EXEC命令触发事务</p>
<h3 id="3特性">3特性</h3>
<h4 id="单独的隔离操作">单独的隔离操作：</h4>
<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<h4 id="没有隔离级别的概念">没有隔离级别的概念：</h4>
<p>队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，<br>
也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</p>
<h4 id="不保证原子性">不保证原子性：</h4>
<p>redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</p>
<h2 id="redis的发布订阅">Redis的发布订阅</h2>
<h3 id="是什么-5">是什么</h3>
<ol>
<li>
<p>进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
</li>
<li>
<p>订阅/发布消息图</p>
<figure data-type="image" tabindex="118"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526215652.png" alt="image-20200526215652277" loading="lazy"></figure>
</li>
</ol>
<h3 id="命令">命令</h3>
<figure data-type="image" tabindex="119"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526215703.png" alt="image-20200526215703858" loading="lazy"></figure>
<h3 id="案例">案例</h3>
<p>先订阅后发布后才能收到消息，</p>
<ol>
<li>
<p>可以一次性订阅多个，SUBSCRIBE c1 c2 c3</p>
<figure data-type="image" tabindex="120"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526222020.png" alt="image-20200526222020051" loading="lazy"></figure>
</li>
<li>
<p>消息发布，PUBLISH c2 hello-redis</p>
<figure data-type="image" tabindex="121"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526222036.png" alt="image-20200526222036785" loading="lazy"></figure>
</li>
<li>
<p>订阅多个，通配符<code>*</code>， PSUBSCRIBE new<code>*</code></p>
<figure data-type="image" tabindex="122"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526221924.png" alt="image-20200526221924183" loading="lazy"></figure>
<figure data-type="image" tabindex="123"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526221950.png" alt="image-20200526221950753" loading="lazy"></figure>
</li>
<li>
<p>收取消息， PUBLISH new1 redis2015。</p>
</li>
</ol>
<h2 id="redis的复制masterslave">Redis的复制(Master/Slave)</h2>
<h3 id="是什么-6">是什么</h3>
<h4 id="官网">官网</h4>
<figure data-type="image" tabindex="124"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528123047.png" alt="image-20200528123047616" loading="lazy"></figure>
<h4 id="行话">行话：</h4>
<p>也就是我们所说的主从复制，主机数据更新后根据配置和策略，<br>
自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主</p>
<h3 id="能干嘛-2">能干嘛</h3>
<ul>
<li>读写分离</li>
<li>容灾恢复</li>
</ul>
<h3 id="怎么玩-2">怎么玩</h3>
<ol>
<li>
<p>配从(库)不配主(库)</p>
</li>
<li>
<p>从库配置：slaveof 主库IP 主库端口</p>
<ul>
<li>每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件</li>
<li>Info replication</li>
</ul>
</li>
<li>
<p>修改配置文件细节操作</p>
<ul>
<li>
<p>拷贝多个redis.conf文件</p>
<figure data-type="image" tabindex="125"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528153928.png" alt="image-20200528153928372" loading="lazy"></figure>
</li>
<li>
<p>开启daemonize yes</p>
<figure data-type="image" tabindex="126"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528153937.png" alt="image-20200528153937412" loading="lazy"></figure>
</li>
<li>
<p>Pid文件名字</p>
</li>
<li>
<p>指定端口</p>
</li>
<li>
<p>Log文件名字</p>
<figure data-type="image" tabindex="127"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528153945.png" alt="image-20200528153945398" loading="lazy"></figure>
</li>
<li>
<p>Dump.rdb名字</p>
<figure data-type="image" tabindex="128"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528153953.png" alt="image-20200528153953166" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>常用3招</p>
<ul>
<li>
<p>一主二仆</p>
<ul>
<li>
<p>Init</p>
<figure data-type="image" tabindex="129"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154124.png" alt="image-20200528154124055" loading="lazy"></figure>
</li>
<li>
<p>一个Master两个Slave</p>
<figure data-type="image" tabindex="130"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154134.png" alt="image-20200528154134404" loading="lazy"></figure>
</li>
<li>
<p>日志查看</p>
<ul>
<li>
<p>主机日志</p>
<figure data-type="image" tabindex="131"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154206.png" alt="image-20200528154206334" loading="lazy"></figure>
</li>
<li>
<p>备机日志</p>
<figure data-type="image" tabindex="132"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154214.png" alt="image-20200528154214600" loading="lazy"></figure>
</li>
<li>
<p>info replication</p>
</li>
</ul>
<figure data-type="image" tabindex="133"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154222.png" alt="image-20200528154221980" loading="lazy"></figure>
</li>
<li>
<p>主从问题演示</p>
<ol>
<li>
<p>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的123是否也可以复制</p>
</li>
<li>
<p>从机是否可以写？set可否？</p>
</li>
<li>
<p>主机shutdown后情况如何？从机是上位还是原地待命</p>
</li>
<li>
<p>主机又回来了后，主机新增记录，从机还能否顺利复制？</p>
</li>
<li>
<p>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>薪火相传</p>
<ul>
<li>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他<br>
slaves的连接和同步请求，那么该slave作为了链条中下一个的master,<br>
可以有效减轻master的写压力</li>
<li>中途变更转向:会清除之前的数据，重新建立拷贝最新的</li>
<li>Slaveof 新主库IP 新主库端口</li>
</ul>
</li>
<li>
<p>反客为主</p>
<ul>
<li>
<p>SLAVEOF no one</p>
<p>使当前数据库停止与其他数据库的同步，转成主数据库。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="复制原理">复制原理</h3>
<ul>
<li>Slave启动成功连接到master后会发送一个sync命令</li>
<li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，<br>
在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li>
<li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li>
<li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li>
</ul>
<h3 id="哨兵模式sentinel">哨兵模式(sentinel)</h3>
<ul>
<li><strong>是什么</strong></li>
</ul>
<blockquote>
<p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p>
</blockquote>
<ul>
<li>
<p><strong>怎么玩(使用步骤)</strong></p>
<ol>
<li>
<p>调整结构，6379带着80、81</p>
</li>
<li>
<p>自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错</p>
</li>
<li>
<p>配置哨兵,填写内容</p>
<ul>
<li>sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1</li>
</ul>
<figure data-type="image" tabindex="134"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154601.png" alt="image-20200528154601200" loading="lazy"></figure>
<ul>
<li>上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机</li>
</ul>
</li>
<li>
<p>启动哨兵</p>
<figure data-type="image" tabindex="135"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154623.png" alt="image-20200528154623843" loading="lazy"></figure>
<ul>
<li>Redis-sentinel /myredis/sentinel.conf</li>
<li>上述目录依照各自的实际情况配置，可能目录不同</li>
</ul>
</li>
<li>
<p>正常主从演示</p>
</li>
<li>
<p>原有的master挂了</p>
<figure data-type="image" tabindex="136"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154633.png" alt="image-20200528154633113" loading="lazy"></figure>
</li>
<li>
<p>投票新选</p>
<figure data-type="image" tabindex="137"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154642.png" alt="image-20200528154642029" loading="lazy"></figure>
</li>
<li>
<p>重新主从继续开工,info replication查查看</p>
<figure data-type="image" tabindex="138"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154649.png" alt="image-20200528154649299" loading="lazy"></figure>
</li>
<li>
<p>问题：如果之前的master重启回来，会不会双master冲突？</p>
<figure data-type="image" tabindex="139"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154703.png" alt="image-20200528154703002" loading="lazy"></figure>
</li>
</ol>
</li>
<li>
<p>一组sentinel能同时监控多个Master</p>
</li>
</ul>
<h3 id="复制的缺点">复制的缺点</h3>
<ul>
<li>
<p>复制延时</p>
<p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux系统下实现远程连接MySQL数据库]]></title>
        <id>https://zoengzihaam.github.io/post/7/</id>
        <link href="https://zoengzihaam.github.io/post/7/">
        </link>
        <updated>2020-06-04T05:09:47.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>MySQL默认root用户只能本地访问，不能远程连接管理mysql数据库。</p>
</blockquote>
<h2 id="步骤">步骤</h2>
<h3 id="1-在服务器端开启远程访问">1. 在服务器端开启远程访问</h3>
<p>首先进入mysql数据库，然后输入下面两个命令：</p>
<pre><code>grant all privileges on *.* to 'root'@'%' identified by '123456';
flush privileges;
</code></pre>
<p>第一个*是数据库，可以改成允许访问的数据库名称</p>
<p>第二个 是数据库的表名称，代表允许访问任意的表</p>
<p>root代表远程登录使用的用户名，可以自定义</p>
<p>%代表允许任意ip登录，如果你想指定特定的IP，可以把%替换掉就可以了</p>
<p>password代表远程登录时使用的密码，可以自定义</p>
<p>flush privileges;这是让权限立即生效</p>
<h3 id="2-修改mycnf配置文件">2. 修改my.cnf配置文件</h3>
<p>这个是mysql的配置文件，如果你无标题文章找不到在哪里的话，可以输入<kbd>find /* -name my.cnf</kbd>找到<br>
通过vim编辑该文件，找到<kbd>bind-address    = 127.0.0.1</kbd>这一句，然后在前面加个#号注释掉，保存退出。</p>
<h3 id="3-重启服务">3. 重启服务</h3>
<pre><code>	service mysql restart
</code></pre>
<h3 id="4-在本地远程连接">4. 在本地远程连接</h3>
<p>在终端输入：</p>
<pre><code>mysql -h 服务器ip地址 -P 3306 -u root -p
</code></pre>
<p>然后输入密码即可。</p>
<p>root是第1点设置的用户名，密码也是第1点设置的密码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tomcat添加SSL证书实现安全]]></title>
        <id>https://zoengzihaam.github.io/post/6/</id>
        <link href="https://zoengzihaam.github.io/post/6/">
        </link>
        <updated>2020-06-04T01:28:04.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>将网站域名申请SSL证书，并把证书配置在Tomcat中，实现进入网站即可跳转https，实现网站安全。</p>
</blockquote>
<h2 id="1下载证书并放置到tomcat安装目录下">1.下载证书并放置到tomcat安装目录下</h2>
<ul>
<li>
<p>在tomcat安装目录下创建一个cert文件夹，将下载的证书中一个jks后缀的证书和一个txt后缀的密码文件上传到tomcat安装目录下</p>
<p>mkdir /usr/local/tomcat/apache-tomcat-8.5.51/cert</p>
</li>
</ul>
<h2 id="2配置serverxml">2.配置server.xml</h2>
<ul>
<li>打开server.xml文件，设置配置文件</li>
</ul>
<pre><code class="language-shell">vim /usr/local/tomcat/apache-tomcat-8.5.51/conf/server.xml
</code></pre>
<ul>
<li>找到Connector标签将8080端口后面的 redirectPort=&quot;8443&quot; 改为</li>
</ul>
<pre><code class="language-shell">redirectPort=&quot;443&quot;
</code></pre>
<ul>
<li>
<p>找到下面SSL/TLS标签把注释的Connector标签打开并添加certificateKeystorePassword属性，里面的值填写下载的密码txt文件里面的内容。</p>
<p><Connector port="443" protocol="org.apache.coyote.http11.Http11NioProtocol"
             maxThreads="150" SSLEnabled="true"><br>
<SSLHostConfig><br>
<Certificate certificateKeystoreFile="cert/证书名.jks" certificateKeystorePassword="zp02e4i10k117u5" type="RSA" /><br>
</SSLHostConfig><br>
</Connector></p>
</li>
</ul>
<h2 id="3配置webxml文件">3.配置web.xml文件</h2>
<ul>
<li>打开tomcat安装目录下的conf文件夹中的web.xml文件</li>
</ul>
<pre><code class="language-shell">vim /usr/local/tomcat/apache-tomcat-8.5.51/conf/web.xml
</code></pre>
<ul>
<li>拉到最下面，找到welcome-file-list标签，在后面添加以下内容</li>
</ul>
<pre><code class="language-xml">&lt;login-config&gt;
    &lt;!-- Authorization setting for SSL --&gt;  
    &lt;auth-method&gt;CLIENT-CERT&lt;/auth-method&gt;  
    &lt;realm-name&gt;Client Cert Users-only Area&lt;/realm-name&gt;  
&lt;/login-config&gt;  
&lt;security-constraint&gt;  
    &lt;!-- Authorization setting for SSL --&gt;  
    &lt;web-resource-collection &gt;  
        &lt;web-resource-name &gt;SSL&lt;/web-resource-name&gt;  
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  
    &lt;/web-resource-collection&gt;  
    &lt;user-data-constraint&gt;  
        &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;  
    &lt;/user-data-constraint&gt;  
&lt;/security-constraint&gt;
</code></pre>
<ul>
<li>
<p>保存退出，将tomcat关闭再次开启。</p>
<pre><code>  **进入bin目录**
</code></pre>
</li>
</ul>
<pre><code class="language-shell">cd /usr/local/tomcat/apache-tomcat-8.5.51/bin
</code></pre>
<p>​		<strong>关闭tomcat</strong></p>
<pre><code class="language-shell">./shutdown.sh
</code></pre>
<p>​		<strong>启动tomcat</strong></p>
<pre><code class="language-shell">./startup.sh
</code></pre>
<p>再次访问网站即可成功安全配置SSL证书到tomcat服务器上。</p>
]]></content>
    </entry>
</feed>