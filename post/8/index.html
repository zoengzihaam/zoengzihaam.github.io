<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    Redis | 卷毛
</title>
<link rel="shortcut icon" href="https://zoengzihaam.github.io/favicon.ico?v=1610627094822">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zoengzihaam.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://zoengzihaam.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
            
                <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
                

                    
                            
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://zoengzihaam.github.io">
                <img class="avatar" src="https://zoengzihaam.github.io/images/avatar.png?v=1610627094822" alt="">
            </a>
            <div class="site-title">
                <h1>
                    卷毛
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            Redis
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-06-04</time>
                            
                                <a href="https://zoengzihaam.github.io/tag/5K5Gk1gnd/" class="post-tag i-tag
                            i-tag-other_4">
                            #Redis
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <blockquote>
<p>多能，数据类型丰富，使用Redis，Tair</p>
<p>Redis:REmote DIctionary Server(远程字典服务器)</p>
<p>是完全开源免费的，用C语言编写的，遵守BSD协议，<br>
是一个高性能的(key/value)分布式内存数据库，基于内存运行<br>
并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,<br>
也被人们称为数据结构服务器</p>
</blockquote>
<h2 id="下载redis">下载Redis</h2>
<p>https://redis.io/download</p>
<h2 id="对redis的理解">对Redis的理解</h2>
<ol>
<li>Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。</li>
<li>KV、Cache、Persistence、...</li>
</ol>
<h2 id="redis的概述">Redis的概述</h2>
<ul>
<li><strong>3V+3高</strong></li>
</ul>
<table>
<thead>
<tr>
<th>3V</th>
<th>3高</th>
</tr>
</thead>
<tbody>
<tr>
<td>海量Volume</td>
<td>高并发</td>
</tr>
<tr>
<td>多样Variety</td>
<td>高可扩</td>
</tr>
<tr>
<td>实时Velocity</td>
<td>高性能</td>
</tr>
</tbody>
</table>
<h2 id="传统关系型数据库">传统关系型数据库</h2>
<p><strong>传统的ACID</strong></p>
<h3 id="1-a-atomicity-原子性">1、A (Atomicity) 原子性</h3>
<p>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</p>
<h3 id="2-c-consistency-一致性">2、C (Consistency) 一致性</h3>
<p>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。</p>
<h3 id="3-i-isolation-独立性">3、I (Isolation) 独立性</h3>
<p>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的</p>
<h3 id="4-d-durability-持久性">4、D (Durability) 持久性</h3>
<p>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</p>
<h2 id="非关系型数据库">非关系型数据库</h2>
<p><strong>CAP</strong></p>
<h3 id="cconsistency强一致性">C:Consistency（强一致性）</h3>
<h3 id="aavailability可用性">A:Availability（可用性）</h3>
<h3 id="ppartition-tolerance分区容错性">P:Partition tolerance（分区容错性）</h3>
<h2 id="redis的安装">Redis的安装</h2>
<blockquote>
<p>Linux版安装</p>
</blockquote>
<ul>
<li>
<p>获取<code>Redis</code>的安装包</p>
<p>将安装包放在/usr/local/redis下</p>
</li>
<li>
<p>解压<code>Redis</code>安装包</p>
</li>
</ul>
<pre><code class="language-shell">tar -zxvf redis-5.0.4.tar.gz
</code></pre>
<ul>
<li>进入Redis目录</li>
</ul>
<pre><code class="language-shell">cd /usr/local/redis/redis-5.0.4
</code></pre>
<ul>
<li>执行<code>make</code>命令</li>
</ul>
<pre><code class="language-shell">make
</code></pre>
<p><font color=red>运行make命令时故<br>
意出现的错误解析：</font></p>
<p>​	安装gcc</p>
<pre><code class="language-shell">yum -y install gcc-c++
</code></pre>
<ul>
<li>执行<code>make install</code>，检验安装</li>
</ul>
<pre><code class="language-shell">make install
</code></pre>
<h2 id="redis基本使用">Redis基本使用</h2>
<h3 id="更改配置">更改配置</h3>
<h4 id="1更改redisconf配置文件">1.更改redis.conf配置文件</h4>
<p>首先备份当前<code>redis.conf</code>文件，修改以下内容。</p>
<pre><code class="language-shell">daemonize yes
</code></pre>
<h3 id="启动">启动</h3>
<p>安装<code>redis</code>之后，在<code>/usr/local/bin</code>会有redis的启动文件。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509140808.png" alt="image-20200509140806730" loading="lazy"></figure>
<ul>
<li>执行<code>redis-server /bak/redis/redis.conf</code>，启动redis并使用指定的配置文件。</li>
</ul>
<pre><code class="language-shell">redis-server /bak/redis/redis.conf
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509140947.png" alt="image-20200509140946468" loading="lazy"></figure>
<h3 id="连通测试">连通测试</h3>
<ul>
<li>执行<code>redis-cli -p 6379</code>来指定端口启动测试。</li>
</ul>
<pre><code class="language-shell">redis-cli -p 6379
</code></pre>
<ul>
<li>使用<code>ping</code>命令来测试连通，出现<code>PONG</code>即为成功。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509141352.png" alt="image-20200509141350989" loading="lazy"></figure>
<ul>
<li>可使用ps -ef|grep redis来查看redis的进程。</li>
</ul>
<pre><code class="language-shell">ps -ef|grep redis
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509141627.png" alt="image-20200509141626567" loading="lazy"></figure>
<h3 id="关闭redis">关闭redis</h3>
<ul>
<li>执行<code>redis-cli shutdown</code>。</li>
</ul>
<pre><code class="language-shell">redis-cli shutdown
</code></pre>
<h2 id="redis可能遇到问题">Redis可能遇到问题</h2>
<ul>
<li><strong>修改配置文件</strong></li>
</ul>
<pre><code class="language-shell">protected-mode no # 关闭保护模式
daemonize yes     # 守护进程模式开启
#bind 127.0.0.1   # 绑定IP按需修改
port 6379         # 端口按需修改
</code></pre>
<ul>
<li><strong>运行并检查端口</strong></li>
</ul>
<pre><code class="language-shell">#启动服务命令
./usr/local/bin/redis-server /bak/redis/redis.conf
#查看6379端口是否占用
netstat -tunpl | grep 6379
</code></pre>
<ul>
<li><strong>开放防火墙端口</strong></li>
</ul>
<pre><code class="language-shell">#开放6379端口
/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT
#保存配置
/etc/rc.d/init.d/iptables save
#重启服务
/etc/rc.d/init.d/iptables restart
#查看端口是否已经开放
/etc/init.d/iptables status
</code></pre>
<h2 id="redis启动后杂项基础知识讲解">Redis启动后杂项基础知识讲解</h2>
<h3 id="单进程">单进程</h3>
<blockquote>
<p>单进程模型来处理客户端的请求。对读写等事件的响应<br>
是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率</p>
</blockquote>
<blockquote>
<p>Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，<br>
它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>
</blockquote>
<h3 id="默认16个数据库">默认16个数据库</h3>
<ul>
<li>
<p>默认16个数据库，类似数组下表从零开始，初始默认使用零号库。</p>
<p>可以使用<code>select &lt;id&gt;</code>来连接指定数据库id</p>
</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509145022.png" alt="image-20200509145021853" loading="lazy"></figure>
<h3 id="dbsize">DBSIZE</h3>
<ul>
<li>Dbsize查看当前数据库的key的数量</li>
</ul>
<pre><code class="language-shell">DBSIZE
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509145149.png" alt="image-20200509145148783" loading="lazy"></figure>
<ul>
<li>使用<code>keys *</code>可查看当前库中的key</li>
</ul>
<pre><code class="language-shell">keys *
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509145301.png" alt="image-20200509145300027" loading="lazy"></figure>
<h3 id="flushdb"><strong>FLUSHDB</strong></h3>
<ul>
<li>清空当前库</li>
</ul>
<pre><code class="language-shell">FLUSHDB
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509145519.png" alt="image-20200509145518458" loading="lazy"></figure>
<h3 id="flushall">FLUSHALL</h3>
<ul>
<li>通杀全部库</li>
</ul>
<pre><code class="language-shell">FLUSHALL
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509145941.png" alt="image-20200509145940266" loading="lazy"></figure>
<h3 id="统一密码管理">统一密码管理</h3>
<h3 id="索引">索引</h3>
<ul>
<li>Reids索引都是从零开始</li>
</ul>
<h3 id="默认端口">默认端口</h3>
<ul>
<li>默认端口是6379</li>
</ul>
<h2 id="redis数据类型">Redis数据类型</h2>
<h3 id="redis的五大数据类型">Redis的五大数据类型</h3>
<h4 id="string字符串">String（字符串）</h4>
<p>String（字符串）</p>
<p>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</p>
<h4 id="hash哈希类似java里的map">Hash（哈希，类似java里的Map）</h4>
<p>Hash（哈希）<br>
Redis hash 是一个键值对集合。<br>
Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>类似Java里面的Map&lt;String,Object&gt;</p>
<h4 id="list列表">List（列表）</h4>
<p>List（列表）<br>
Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。<br>
它的底层实际是个链表</p>
<h4 id="set集合">Set（集合）</h4>
<p>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的。</p>
<h4 id="zsetsorted-set有序集合">Zset(sorted set：有序集合)</h4>
<p>zset(sorted set：有序集合)<br>
Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>
不同的是每个元素都会关联一个double类型的分数。<br>
redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>
<h3 id="哪里去获得redis常见数据类型操作命令">哪里去获得redis常见数据类型操作命令</h3>
<ul>
<li>Http://redisdoc.com/</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509163322.png" alt="image-20200509163320729" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509150946.png" alt="image-20200509150945470" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509163404.png" alt="image-20200509163403248" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509163452.png" alt="image-20200509163445728" loading="lazy"></figure>
<h3 id="redis-键key">Redis 键(key)</h3>
<ul>
<li><strong>常用</strong></li>
</ul>
<figure data-type="image" tabindex="14"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509164137.png" alt="image-20200509164136826" loading="lazy"></figure>
<ul>
<li>
<p><strong>案例</strong></p>
<ul>
<li><code>keys *</code></li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509164723.png" alt="image-20200509164721746" loading="lazy"></figure>
<ul>
<li><code>exists key</code>的名字，判断某个key是否存在。</li>
</ul>
<figure data-type="image" tabindex="16"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509164759.png" alt="image-20200509164758524" loading="lazy"></figure>
<ul>
<li><code>move key db</code>，移动当前库的key到指定的库中。</li>
</ul>
<figure data-type="image" tabindex="17"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509164846.png" alt="image-20200509164845216" loading="lazy"></figure>
<ul>
<li><code>expire key</code>，给指定的key设置一个过期时间。</li>
</ul>
<figure data-type="image" tabindex="18"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509165816.png" alt="image-20200509165815934" loading="lazy"></figure>
<ul>
<li><code>ttl key</code>，查看当前key的过期时间，-1表示永不过期，-2表示已过期。</li>
</ul>
<p>当key过期的时候，代表当前key的生命周期已经结束，所以在当前库中就不存在这个key。</p>
<figure data-type="image" tabindex="19"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509165609.png" alt="image-20200509165607432" loading="lazy"></figure>
<ul>
<li><code>type key</code>，查看当前的key的类型。</li>
</ul>
<figure data-type="image" tabindex="20"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509171236.png" alt="image-20200509171235161" loading="lazy"></figure>
<ul>
<li><code>del key</code>，删除当前的key</li>
</ul>
<figure data-type="image" tabindex="21"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509171824.png" alt="image-20200509171823453" loading="lazy"></figure>
</li>
</ul>
<h3 id="redis字符串string">Redis字符串(String)</h3>
<ul>
<li><strong>常用</strong></li>
</ul>
<figure data-type="image" tabindex="22"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509163741.png" alt="image-20200509163740370" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509163758.png" alt="image-20200509163757223" loading="lazy"></figure>
<ul>
<li>
<p><strong>单值单value</strong></p>
</li>
<li>
<p><strong>案例</strong></p>
<ul>
<li><code>set key value</code>，设置一个K,V</li>
</ul>
<figure data-type="image" tabindex="24"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509172150.png" alt="image-20200509172149069" loading="lazy"></figure>
<ul>
<li><code>get key</code>，获取当前key的value值。</li>
</ul>
<figure data-type="image" tabindex="25"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509172214.png" alt="image-20200509172212935" loading="lazy"></figure>
<ul>
<li><code>append key value</code>，在指定key的value值后添加指定的值。</li>
</ul>
<figure data-type="image" tabindex="26"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509172309.png" alt="image-20200509172308003" loading="lazy"></figure>
<ul>
<li><code>strlen key</code>，查询当前key的长度。</li>
</ul>
<figure data-type="image" tabindex="27"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509172350.png" alt="image-20200509172348777" loading="lazy"></figure>
<ul>
<li><code>incr key</code>，对当前的key进行递增。</li>
</ul>
<figure data-type="image" tabindex="28"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509172909.png" alt="image-20200509172908900" loading="lazy"></figure>
<ul>
<li><code>decr key</code>，对当前的key进行递减。</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="29"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509173003.png" alt="image-20200509173003082" loading="lazy"></figure>
<p><code>incrby key num</code>，对当前的key进行指定数字的递增。</p>
<figure data-type="image" tabindex="30"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509173838.png" alt="image-20200509173837831" loading="lazy"></figure>
<p><code>decrby key num</code>，对当前的key进行指定数字的递减。</p>
<figure data-type="image" tabindex="31"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509173919.png" alt="image-20200509173918434" loading="lazy"></figure>
<p>**注意：**一定要是数字才能进行加减。</p>
<p><code>getrange key start end</code>，获取当前key字符串的指定长度内容。</p>
<figure data-type="image" tabindex="32"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509174324.png" alt="image-20200509174323706" loading="lazy"></figure>
<p><code>setrange key index str</code>，设置当前key字符串指定下标开始，设置str内容。</p>
<figure data-type="image" tabindex="33"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509174716.png" alt="image-20200509174714625" loading="lazy"></figure>
<p><code>setex key second value</code>setex(set with expire)，设置K,V，并设置到期时间。</p>
<figure data-type="image" tabindex="34"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509175112.png" alt="image-20200509175111603" loading="lazy"></figure>
<p><code>setnx key value</code>，setnx(set if not exist)，只有当前key不存在的时候，设置key的值。</p>
<figure data-type="image" tabindex="35"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509175337.png" alt="image-20200509175336269" loading="lazy"></figure>
<p><code>mset key1 value1 key2 value2 key3 value3</code>，设置多个K,V。</p>
<figure data-type="image" tabindex="36"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509175550.png" alt="image-20200509175549643" loading="lazy"></figure>
<p><code>mget key1 key2 key3</code>，获取多个指定key的值。</p>
<figure data-type="image" tabindex="37"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200509175651.png" alt="image-20200509175650583" loading="lazy"></figure>
<p><code>msetnx key1 value1 key2 value2 key3 value3</code>，设置多个值，当设置key不存在时，设置指定key值，如果一个不存在，则都不设置。</p>
<figure data-type="image" tabindex="38"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200511174045.png" alt="" loading="lazy"></figure>
<h3 id="redis列表list">Redis列表(List)</h3>
<ul>
<li>常用</li>
</ul>
<figure data-type="image" tabindex="39"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200511175624.png" alt="image-20200511175622928" loading="lazy"></figure>
<figure data-type="image" tabindex="40"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200511175638.png" alt="image-20200511175637169" loading="lazy"></figure>
<ul>
<li>
<p>单值多value</p>
</li>
<li>
<p>案例</p>
<ul>
<li><code>lpush key value1 [value2]</code>，将一个或多个值插入到列表头部。</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="41"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200512213854.png" alt="image-20200512213850399" loading="lazy"></figure>
<p><code>rpush key value1 [value2]</code>，在列表中添加一个或多个值</p>
<figure data-type="image" tabindex="42"><img src="D:%5C%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Credis%5Cupload%5Cimage-20200512214133456.png" alt="image-20200512214133456" loading="lazy"></figure>
<p><code>lrange key start end</code>，获取列表指定范围内的元素</p>
<figure data-type="image" tabindex="43"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200512214536.png" alt="image-20200512214535408" loading="lazy"></figure>
<p><code>lpop key</code>，移除并获取列表的第一个元素</p>
<figure data-type="image" tabindex="44"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200512215656.png" alt="image-20200512215655300" loading="lazy"></figure>
<p><code>rpop key</code>，移除并获取列表最后一个元素。</p>
<figure data-type="image" tabindex="45"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200513121600.png" alt="image-20200513121559312" loading="lazy"></figure>
<p><code>lindex key index</code>，根据下标，查询执行列表中的数据。</p>
<figure data-type="image" tabindex="46"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200513122104.png" alt="image-20200513122102884" loading="lazy"></figure>
<p><code>llen key</code>，查询指定列表的长度</p>
<figure data-type="image" tabindex="47"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200513122214.png" alt="image-20200513122213323" loading="lazy"></figure>
<p><code>lrem key count value</code>，移除指定列表指定数量的值。</p>
<figure data-type="image" tabindex="48"><img src="https://cdn.jsdelivr.net/gh/zoengzihaam/ImgBed@master/images/20200513122536.png" alt="image-20200513122535830" loading="lazy"></figure>
<p><code>ltrim key start end</code>，截取指定列表的指定下标内容，然后赋值给这个列表。</p>
<figure data-type="image" tabindex="49"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200513123043.png" alt="image-20200513123000885" loading="lazy"></figure>
<p><code>rpoplpush source destination</code>，移除列表的最后一个元素，并将该元素添加到另一个列表并返回。</p>
<figure data-type="image" tabindex="50"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518171755.png" alt="image-20200518170936054" loading="lazy"></figure>
<p><code>lset key index value</code>，通过索引设置列表元素的值。</p>
<figure data-type="image" tabindex="51"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518172222.png" alt="image-20200518172221911" loading="lazy"></figure>
<p><code>linsert key before|after pivot value</code>，在列表的元素前或者后插入元素。</p>
<figure data-type="image" tabindex="52"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518172734.png" alt="image-20200518172733735" loading="lazy"></figure>
<h3 id="redis集合set">Redis集合(Set)</h3>
<ul>
<li>常用</li>
</ul>
<figure data-type="image" tabindex="53"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518173358.png" alt="image-20200518173357120" loading="lazy"></figure>
<ul>
<li>
<p>单值多value</p>
</li>
<li>
<p>案例</p>
<ul>
<li><code>sadd key member1 [member2]</code>，向集合添加一个或多个成员。</li>
</ul>
<figure data-type="image" tabindex="54"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518173952.png" alt="image-20200518173848658" loading="lazy"></figure>
<ul>
<li><code>smembers key</code>，返回集合中的所有成员</li>
</ul>
<figure data-type="image" tabindex="55"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518174145.png" alt="image-20200518174144650" loading="lazy"></figure>
<ul>
<li><code>sismember key member</code>，判断 member 元素是否是集合key的成员。</li>
</ul>
<figure data-type="image" tabindex="56"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518174329.png" alt="image-20200518174328349" loading="lazy"></figure>
<ul>
<li><code>scard key</code>，获取集合的成员数</li>
</ul>
<figure data-type="image" tabindex="57"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518174531.png" alt="image-20200518174530718" loading="lazy"></figure>
<ul>
<li><code>srem key member1 [member2]</code>，移除集合中一个或多个成员</li>
</ul>
<figure data-type="image" tabindex="58"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518174653.png" alt="image-20200518174652704" loading="lazy"></figure>
<ul>
<li><code>srandmember key [count]</code>，返回集合中一个或多个随机数。</li>
</ul>
<figure data-type="image" tabindex="59"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518174943.png" alt="image-20200518174941232" loading="lazy"></figure>
<ul>
<li><code>spop key</code>，移除并返回集合中的一个随机元素</li>
</ul>
<figure data-type="image" tabindex="60"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200518175932.png" alt="image-20200518175930355" loading="lazy"></figure>
<ul>
<li><code>smove key1 key2 member</code>，将member元素从key1集合移动到key2集合。</li>
</ul>
<figure data-type="image" tabindex="61"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519221958.png" alt="image-20200519221957915" loading="lazy"></figure>
<ul>
<li>
<p>数学集合类</p>
<ul>
<li><code>sdiff key1 [key2]</code>，返回给定所有集合的差集。（在第一个set里面而不在后面任何一个set里面的项）</li>
</ul>
<figure data-type="image" tabindex="62"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519222408.png" alt="image-20200519222407399" loading="lazy"></figure>
<ul>
<li><code>sinter key1 [key2]</code>，返回给定所有集合的交集。</li>
</ul>
<figure data-type="image" tabindex="63"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519222629.png" alt="image-20200519222628138" loading="lazy"></figure>
<ul>
<li><code>sunion key1 [key2]</code>，返回所有给定集合的并集。</li>
</ul>
<figure data-type="image" tabindex="64"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519222823.png" alt="image-20200519222822998" loading="lazy"></figure>
</li>
</ul>
</li>
</ul>
<h3 id="redis哈希hash">Redis哈希(Hash)</h3>
<ul>
<li>常用</li>
</ul>
<figure data-type="image" tabindex="65"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519223109.png" alt="image-20200519223106752" loading="lazy"></figure>
<ul>
<li>
<p>KV模式不变，但V是一个键值对。</p>
</li>
<li>
<p>案例</p>
<ul>
<li><code>hset key field value</code>，将哈希表key中 的字段field的值设为value。</li>
</ul>
<figure data-type="image" tabindex="66"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519223639.png" alt="image-20200519223620338" loading="lazy"></figure>
<ul>
<li><code>hget key field</code>，获取存储在哈希表中指定field字段的值。</li>
</ul>
<figure data-type="image" tabindex="67"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519223621.png" alt="image-20200519223620338" loading="lazy"></figure>
<ul>
<li><code>hmset key field1 value1 [field2 value2]</code>，同时将多个field-value(域-值)对设置到哈希表key中。</li>
</ul>
<figure data-type="image" tabindex="68"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519224026.png" alt="image-20200519224025622" loading="lazy"></figure>
<ul>
<li><code>hgetall key</code>，获得存储在哈希表中指定key的所有字段和值。</li>
</ul>
<figure data-type="image" tabindex="69"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519224211.png" alt="image-20200519224210926" loading="lazy"></figure>
<ul>
<li><code>hdel key field</code>，删除存储在哈希表中key 指定字段。</li>
</ul>
<figure data-type="image" tabindex="70"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519224352.png" alt="image-20200519224351205" loading="lazy"></figure>
<ul>
<li><code>hexists key field</code>，查询存储在哈希表中指定字段是否存在</li>
</ul>
<figure data-type="image" tabindex="71"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519224931.png" alt="image-20200519224930651" loading="lazy"></figure>
<ul>
<li><code>hkeys key</code>，获取所有哈希表中的字段</li>
</ul>
<figure data-type="image" tabindex="72"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519225102.png" alt="image-20200519225101378" loading="lazy"></figure>
<ul>
<li><code>hvals keys</code>，获取哈希表中所有的值。</li>
</ul>
<figure data-type="image" tabindex="73"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519225150.png" alt="image-20200519225149340" loading="lazy"></figure>
<ul>
<li><code>hincrby key field increment</code>，为哈希表key中的指定字段的整数值加上增量increment。</li>
</ul>
<figure data-type="image" tabindex="74"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519225443.png" alt="image-20200519225442220" loading="lazy"></figure>
<ul>
<li><code>hincrbyfloat key field increment</code>，为哈希表中的指定字段的浮点数值加上增量increment。</li>
</ul>
<figure data-type="image" tabindex="75"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519225615.png" alt="image-20200519225614338" loading="lazy"></figure>
<ul>
<li><code>hsetnx key field value</code>，只有在字段field不存在时，设置哈希表字段的值。</li>
</ul>
<figure data-type="image" tabindex="76"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200519225935.png" alt="image-20200519225934654" loading="lazy"></figure>
</li>
</ul>
<h3 id="redis有序集合zsetsorted-set">Redis有序集合Zset(sorted set)</h3>
<ul>
<li>常用</li>
</ul>
<figure data-type="image" tabindex="77"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521150248.png" alt="image-20200521150246364" loading="lazy"></figure>
<figure data-type="image" tabindex="78"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521151239.png" alt="image-20200521151229536" loading="lazy"></figure>
<ul>
<li>
<p>案例</p>
<ul>
<li><code>zadd key score1 member1 [score2 member2]</code>，向有序集合添加一个或多个成员，或者更新已存在成员的分数。</li>
</ul>
<figure data-type="image" tabindex="79"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521151041.png" alt="image-20200521151040926" loading="lazy"></figure>
<ul>
<li><code>zrangebyscore key start end</code>，通过分数返回有序集合指定区间内的成员。</li>
</ul>
<figure data-type="image" tabindex="80"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521152441.png" alt="image-20200521152440530" loading="lazy"></figure>
<ul>
<li><code>zrangebyscore key (start end</code>，通过返回有序集合指定区间内(带有<code>(</code>，说明不包含)的成员。</li>
</ul>
<figure data-type="image" tabindex="81"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521160141.png" alt="image-20200521160140065" loading="lazy"></figure>
<ul>
<li><code>zrem key member</code>，根据对应的value值删除有序集合中的成员元素。</li>
</ul>
<figure data-type="image" tabindex="82"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521160744.png" alt="image-20200521160743971" loading="lazy"></figure>
<ul>
<li><code>zcard key</code>，获得有序列表中的成员数。</li>
</ul>
<figure data-type="image" tabindex="83"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521163302.png" alt="image-20200521163301419" loading="lazy"></figure>
<ul>
<li><code>zcount key min max</code>，查询在有序列表中指定区间的成员数。</li>
</ul>
<figure data-type="image" tabindex="84"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521163434.png" alt="image-20200521163426648" loading="lazy"></figure>
<ul>
<li><code>zrank key value</code>，获取指定成员在有序列表中的下标。</li>
</ul>
<figure data-type="image" tabindex="85"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521163702.png" alt="image-20200521163701613" loading="lazy"></figure>
<ul>
<li><code>zscore key value</code>，获取有序列表中指定成员的值。</li>
</ul>
<figure data-type="image" tabindex="86"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521163813.png" alt="image-20200521163813036" loading="lazy"></figure>
<ul>
<li><code>zrevrank key values</code>，逆序获得下标值。</li>
</ul>
<figure data-type="image" tabindex="87"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521163956.png" alt="image-20200521163955191" loading="lazy"></figure>
</li>
</ul>
<h2 id="解析配置文件redisconf">解析配置文件redis.conf</h2>
<h3 id="1它在哪">1.它在哪</h3>
<ul>
<li>
<p>地址。</p>
<p>进入redis目录下，使用<code>pwd</code>命令来查看当前目录。</p>
</li>
</ul>
<figure data-type="image" tabindex="88"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521165404.png" alt="image-20200521165403592" loading="lazy"></figure>
<ul>
<li>
<p>为什么拷贝出来单独执行？</p>
<p>通常为了配置的安全，放置在原文件配置错误，导致无法正常运行。</p>
</li>
</ul>
<h3 id="2units单位">2.Units单位</h3>
<figure data-type="image" tabindex="89"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521165629.png" alt="image-20200521165628558" loading="lazy"></figure>
<h3 id="3includes包含">3.INCLUDES包含</h3>
<ul>
<li>和其他配置文件一样，可以通过includes包含，redis.conf可以作为总闸，包含其他。</li>
</ul>
<figure data-type="image" tabindex="90"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521170957.png" alt="image-20200521170956374" loading="lazy"></figure>
<h3 id="4general通用">4.GENERAL通用</h3>
<h4 id="daemonize">daemonize</h4>
<ul>
<li>介绍
<ul>
<li>A、redis.conf配置文件中daemonize守护线程，默认是NO。</li>
<li>B、daemonize是用来指定redis是否要用守护线程的方式启动。</li>
</ul>
</li>
<li>daemonize 设置yes或者no区别
<ul>
<li><code>daemonize:yes</code>:redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。</li>
<li><code>daemonize:no</code>: 当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。</li>
</ul>
</li>
</ul>
<h4 id="pidfile">Pidfile</h4>
<ul>
<li>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定。</li>
</ul>
<h4 id="port">Port</h4>
<ul>
<li>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字。</li>
</ul>
<h4 id="tcp-backlog">Tcp-backlog</h4>
<ul>
<li>
<p>文档解释</p>
<p>tcp-backlog<br>
设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。<br>
在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值来达到想要的效果。</p>
</li>
</ul>
<h4 id="timeout">Timeout</h4>
<ul>
<li>当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能。</li>
</ul>
<h4 id="bind">Bind</h4>
<ul>
<li>绑定的主机地址</li>
</ul>
<h4 id="tcp-keepalive">Tcp-keepalive</h4>
<ul>
<li>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60。</li>
</ul>
<h4 id="loglevel">Loglevel</h4>
<ul>
<li>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice</li>
</ul>
<h4 id="logfile">Logfile</h4>
<ul>
<li>指定日志文件的路径。</li>
</ul>
<h4 id="syslog-enabled">Syslog-enabled</h4>
<ul>
<li>是否把日志输出到syslog中。默认是no。</li>
</ul>
<h4 id="syslog-ident">Syslog-ident</h4>
<ul>
<li>指定syslog里的日志标志。默认是redis。</li>
</ul>
<h4 id="syslog-facility">Syslog-facility</h4>
<ul>
<li>指定syslog设备，值可以是USER或LOCAL0-LOCAL7。默认是LOCAL0。</li>
</ul>
<h4 id="databases">Databases</h4>
<ul>
<li>设置数据库的数量，默认数量为16，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id。</li>
</ul>
<h3 id="5snapshotting快照">5.SNAPSHOTTING快照</h3>
<h4 id="save">Save</h4>
<ul>
<li>save 秒钟 写操作次数</li>
</ul>
<p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，<br>
默认<br>
是1分钟内改了1万次，<br>
或5分钟内改了10次，<br>
或15分钟内改了1次。</p>
<figure data-type="image" tabindex="91"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525102515.png" alt="image-20200525102515280" loading="lazy"></figure>
<ul>
<li>禁用</li>
</ul>
<p>如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。</p>
<figure data-type="image" tabindex="92"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525102536.png" alt="image-20200525102536487" loading="lazy"></figure>
<ul>
<li>如果想即可备份，使用<code>save</code>命令，可执行立即备份功能。</li>
</ul>
<h4 id="stop-writes-on-bgsave-error">Stop-writes-on-bgsave-error</h4>
<p>如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制。</p>
<figure data-type="image" tabindex="93"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525102558.png" alt="image-20200525102558301" loading="lazy"></figure>
<h4 id="rdbcompression">rdbcompression</h4>
<p>rdbcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用<br>
LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能</p>
<h4 id="rdbchecksum">rdbchecksum</h4>
<h4 id="dbfilename">dbfilename</h4>
<h4 id="dir">dir</h4>
<h3 id="6replication复制">6.REPLICATION复制</h3>
<h3 id="7security安全">7.SECURITY安全</h3>
<ul>
<li>访问密码的查看、设置和取消。</li>
</ul>
<figure data-type="image" tabindex="94"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200521173800.png" alt="image-20200521173759042" loading="lazy"></figure>
<h3 id="8limits限制">8.LIMITS限制</h3>
<h4 id="maxclients">Maxclients</h4>
<ul>
<li>设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当你<br>
无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自<br>
身内部处理逻辑留一些句柄出来。如果达到了此限制，redis则会拒绝新的连接请求，并且向这<br>
些连接请求方发出“max number of clients reached”以作回应。</li>
</ul>
<h4 id="maxmemory">Maxmemory</h4>
<ul>
<li>
<p>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，<br>
那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</p>
<p>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>
</li>
</ul>
<h4 id="maxmemory-policy">Maxmemory-policy</h4>
<ul>
<li>（1）volatile-lru：使用LRU算法移除key，只对设置了过期时间的键。</li>
<li>（2）allkeys-lru：使用LRU算法移除key。</li>
<li>（3）volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键。</li>
<li>（4）allkeys-random：移除随机的key。</li>
<li>（5）volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key。</li>
<li>（6）noeviction：不进行移除。针对写操作，只是返回错误信息。</li>
</ul>
<h4 id="maxmemory-samples">Maxmemory-samples</h4>
<ul>
<li>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，<br>
redis默认会检查这么多个key并选择其中LRU的那个。</li>
</ul>
<h3 id="9append-only-mode追加">9.APPEND ONLY MODE追加</h3>
<h4 id="appendonly">appendonly</h4>
<h4 id="appendfilename">appendfilename</h4>
<h4 id="appendfsync">Appendfsync</h4>
<figure data-type="image" tabindex="95"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525210259.png" alt="image-20200525210259806" loading="lazy"></figure>
<ul>
<li>Always：同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好。</li>
<li>Everysec：出厂默认推荐，异步操作，每秒记录   如果一秒内宕机，有数据丢失。</li>
<li>No</li>
</ul>
<h4 id="no-appendfsync-on-rewrite重写时是否可以运用appendfsync用默认no即可保证数据安全性">No-appendfsync-on-rewrite：重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。</h4>
<h4 id="auto-aof-rewrite-min-size设置重写的基准值">Auto-aof-rewrite-min-size：设置重写的基准值</h4>
<h4 id="auto-aof-rewrite-percentage设置重写的基准值">Auto-aof-rewrite-percentage：设置重写的基准值</h4>
<h2 id="redis的持久化">Redis的持久化</h2>
<h3 id="总体介绍">总体介绍</h3>
<h4 id="官网介绍">官网介绍</h4>
<figure data-type="image" tabindex="96"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200524221645.png" alt="image-20200524221645176" loading="lazy"></figure>
<h3 id="rdbredis-database">RDB（Redis DataBase）</h3>
<h4 id="官网介绍-2">官网介绍</h4>
<figure data-type="image" tabindex="97"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200524221834.png" alt="image-20200524221834175" loading="lazy"></figure>
<h4 id="是什么">是什么：</h4>
<ul>
<li>在指定的时间间隔内将内存中的数据集快照写入磁盘，<br>
也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</li>
<li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到<br>
一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。<br>
整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能<br>
如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方<br>
式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</li>
</ul>
<h4 id="fork">Fork</h4>
<ul>
<li>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）<br>
数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</li>
</ul>
<h4 id="rdb-保存的是dumprdb文件">Rdb 保存的是dump.rdb文件</h4>
<h4 id="配置位置">配置位置</h4>
<figure data-type="image" tabindex="98"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200524223800.png" alt="image-20200524223800247" loading="lazy"></figure>
<h4 id="如何触发rdb快照">如何触发RDB快照</h4>
<h5 id="配置文件中默认的快照配置">配置文件中默认的快照配置</h5>
<figure data-type="image" tabindex="99"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525104217.png" alt="image-20200525104217106" loading="lazy"></figure>
<ul>
<li>
<p>冷拷贝后重新使用</p>
<p>可以cp dump.rdb dump_new.rdb</p>
</li>
</ul>
<h5 id="命令save或者是bgsave">命令save或者是bgsave</h5>
<ul>
<li>Save：save时只管保存，其它不管，全部阻塞</li>
</ul>
<figure data-type="image" tabindex="100"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525104534.png" alt="image-20200525104534717" loading="lazy"></figure>
<ul>
<li>BGSAVE：Redis会在后台异步进行快照操作，<br>
快照同时还可以响应客户端请求。可以通过lastsave<br>
命令获取最后一次成功执行快照的时间</li>
</ul>
<h5 id="执行flushall命令也会产生dumprdb文件但里面是空的无意义">执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</h5>
<h4 id="如何恢复">如何恢复</h4>
<ul>
<li>
<p>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</p>
</li>
<li>
<p>CONFIG GET dir获取目录</p>
</li>
</ul>
<h4 id="优势">优势</h4>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
</ul>
<h4 id="劣势">劣势</h4>
<ul>
<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就<br>
会丢失最后一次快照后的所有修改</li>
<li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
</ul>
<h4 id="如何停止">如何停止</h4>
<ul>
<li>动态所有停止RDB保存规则的方法：redis-cli config set save &quot;&quot;</li>
</ul>
<h4 id="小总结">小总结</h4>
<figure data-type="image" tabindex="101"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525105545.png" alt="image-20200525105545632" loading="lazy"></figure>
<h3 id="aofappend-only-file">AOF（Append Only File）</h3>
<h4 id="官网介绍-3">官网介绍</h4>
<figure data-type="image" tabindex="102"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525110108.png" alt="image-20200525110108706" loading="lazy"></figure>
<h4 id="是什么-2">是什么：</h4>
<blockquote>
<p><strong>以日志的形式来记录每个写操作</strong>，将Redis执行过的所有写指令记录下来(读操作不记录)，<br>
只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
</blockquote>
<h4 id="aof保存的是appendonlyaof文件">Aof保存的是appendonly.aof文件</h4>
<h4 id="配置位置-2">配置位置</h4>
<figure data-type="image" tabindex="103"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525205831.png" alt="image-20200525205831351" loading="lazy"></figure>
<h4 id="aof启动修复恢复">AOF启动/修复/恢复</h4>
<h5 id="正常恢复">正常恢复</h5>
<ul>
<li>启动：设置Yes</li>
<li>修改默认的appendonly no，改为yes</li>
<li>将有数据的aof文件复制一份保存到对应目录(config get dir)。</li>
<li>恢复：重启redis然后重新加载。</li>
</ul>
<h5 id="异常恢复">异常恢复</h5>
<ul>
<li>启动：设置Yes</li>
<li>修改默认的appendonly no，改为yes。</li>
<li>备份被写坏的AOF文件</li>
<li>修复：Redis-check-aof --fix进行修复</li>
<li>恢复：重启redis然后重新加载</li>
</ul>
<h4 id="rewrite">Rewrite</h4>
<figure data-type="image" tabindex="104"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525212540.png" alt="image-20200525212540047" loading="lazy"></figure>
<h5 id="是什么-3">是什么：</h5>
<blockquote>
<p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,<br>
当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，<br>
只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p>
</blockquote>
<h5 id="重写原理">重写原理</h5>
<p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，<br>
遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，<br>
而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。</p>
<h5 id="触发机制">触发机制</h5>
<p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。</p>
<h4 id="优势-2">优势</h4>
<h5 id="每修改同步">每修改同步：</h5>
<p>appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好。</p>
<h5 id="每秒同步">每秒同步：</h5>
<p>appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失</p>
<h5 id="不同步">不同步：</h5>
<p>appendfsync no   从不同步。</p>
<h4 id="劣势-2">劣势</h4>
<ol>
<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb。</li>
<li>Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同。</li>
</ol>
<h4 id="小总结-2">小总结</h4>
<figure data-type="image" tabindex="105"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525212854.png" alt="image-20200525212854369" loading="lazy"></figure>
<h3 id="总结which-one">总结(Which one)</h3>
<h4 id="官网建议">官网建议</h4>
<figure data-type="image" tabindex="106"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200525212951.png" alt="image-20200525212951704" loading="lazy"></figure>
<ol>
<li>
<p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。</p>
</li>
<li>
<p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些<br>
命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.<br>
Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。</p>
</li>
<li>
<p>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式。</p>
</li>
<li>
<p>同时开启两种持久化方式。</p>
<ul>
<li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,<br>
因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？<br>
作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，<br>
快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li>
</ul>
</li>
<li>
<p>性能建议。</p>
<ul>
<li>
<p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</p>
<p>如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</p>
<p>如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构。</p>
</li>
</ul>
</li>
</ol>
<h2 id="redis的事务">Redis的事务</h2>
<h3 id="是什么-4">是什么</h3>
<blockquote>
<p>可以一次执行多个命令，本质是一组命令的集合。一个事务中的<br>
所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞。</p>
</blockquote>
<ul>
<li>官网</li>
</ul>
<figure data-type="image" tabindex="107"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095415.png" alt="image-20200526095415167" loading="lazy"></figure>
<h3 id="能干嘛">能干嘛</h3>
<ul>
<li>一个队列中，一次性、顺序性、排他性的执行一系列命令。</li>
</ul>
<h3 id="怎么玩">怎么玩</h3>
<figure data-type="image" tabindex="108"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095448.png" alt="image-20200526095448303" loading="lazy"></figure>
<h4 id="常用命令">常用命令</h4>
<figure data-type="image" tabindex="109"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095615.png" alt="image-20200526095615512" loading="lazy"></figure>
<h4 id="case1正常执行">Case1：正常执行</h4>
<figure data-type="image" tabindex="110"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095635.png" alt="image-20200526095635884" loading="lazy"></figure>
<h4 id="case2放弃事务">Case2：放弃事务</h4>
<figure data-type="image" tabindex="111"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095644.png" alt="image-20200526095644734" loading="lazy"></figure>
<h4 id="case3全体连坐">Case3：全体连坐</h4>
<figure data-type="image" tabindex="112"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095652.png" alt="image-20200526095652384" loading="lazy"></figure>
<h4 id="case4冤头债主">Case4：冤头债主</h4>
<figure data-type="image" tabindex="113"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526095701.png" alt="image-20200526095701700" loading="lazy"></figure>
<h4 id="case5watch监控">Case5：watch监控</h4>
<ol>
<li>
<p>悲观锁/乐观锁/CAS(Check And Set)</p>
<ul>
<li>
<p>悲观锁</p>
<p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
</li>
<li>
<p>乐观锁</p>
<p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，</p>
<p>乐观锁策略:提交版本必须大于记录当前版本才能执行更新。</p>
</li>
<li>
<p>CAS</p>
</li>
</ul>
</li>
<li>
<p>初始化信用卡可用余额和欠额</p>
<figure data-type="image" tabindex="114"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526100000.png" alt="image-20200526095959959" loading="lazy"></figure>
</li>
<li>
<p>无加塞篡改，先监控再开启multi，保证两笔金额变动在同一个事务内。</p>
<figure data-type="image" tabindex="115"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526100012.png" alt="image-20200526100012139" loading="lazy"></figure>
</li>
<li>
<p>有加塞篡改。</p>
<figure data-type="image" tabindex="116"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526100020.png" alt="image-20200526100020441" loading="lazy"></figure>
</li>
<li>
<p>unwatch</p>
<figure data-type="image" tabindex="117"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526100028.png" alt="image-20200526100028027" loading="lazy"></figure>
</li>
<li>
<p>一旦执行了exec之前加的监控锁都会被取消掉了</p>
</li>
<li>
<p>小结</p>
<ul>
<li>Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变，<br>
比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行。</li>
<li>通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，<br>
EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</li>
</ul>
</li>
</ol>
<h3 id="3阶段">3阶段</h3>
<h4 id="开启">开启：</h4>
<p>以MULTI开始一个事务。</p>
<h4 id="入队">入队：</h4>
<p>将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</p>
<h4 id="执行">执行：</h4>
<p>由EXEC命令触发事务</p>
<h3 id="3特性">3特性</h3>
<h4 id="单独的隔离操作">单独的隔离操作：</h4>
<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<h4 id="没有隔离级别的概念">没有隔离级别的概念：</h4>
<p>队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，<br>
也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</p>
<h4 id="不保证原子性">不保证原子性：</h4>
<p>redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</p>
<h2 id="redis的发布订阅">Redis的发布订阅</h2>
<h3 id="是什么-5">是什么</h3>
<ol>
<li>
<p>进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
</li>
<li>
<p>订阅/发布消息图</p>
<figure data-type="image" tabindex="118"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526215652.png" alt="image-20200526215652277" loading="lazy"></figure>
</li>
</ol>
<h3 id="命令">命令</h3>
<figure data-type="image" tabindex="119"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526215703.png" alt="image-20200526215703858" loading="lazy"></figure>
<h3 id="案例">案例</h3>
<p>先订阅后发布后才能收到消息，</p>
<ol>
<li>
<p>可以一次性订阅多个，SUBSCRIBE c1 c2 c3</p>
<figure data-type="image" tabindex="120"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526222020.png" alt="image-20200526222020051" loading="lazy"></figure>
</li>
<li>
<p>消息发布，PUBLISH c2 hello-redis</p>
<figure data-type="image" tabindex="121"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526222036.png" alt="image-20200526222036785" loading="lazy"></figure>
</li>
<li>
<p>订阅多个，通配符<code>*</code>， PSUBSCRIBE new<code>*</code></p>
<figure data-type="image" tabindex="122"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526221924.png" alt="image-20200526221924183" loading="lazy"></figure>
<figure data-type="image" tabindex="123"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200526221950.png" alt="image-20200526221950753" loading="lazy"></figure>
</li>
<li>
<p>收取消息， PUBLISH new1 redis2015。</p>
</li>
</ol>
<h2 id="redis的复制masterslave">Redis的复制(Master/Slave)</h2>
<h3 id="是什么-6">是什么</h3>
<h4 id="官网">官网</h4>
<figure data-type="image" tabindex="124"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528123047.png" alt="image-20200528123047616" loading="lazy"></figure>
<h4 id="行话">行话：</h4>
<p>也就是我们所说的主从复制，主机数据更新后根据配置和策略，<br>
自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主</p>
<h3 id="能干嘛-2">能干嘛</h3>
<ul>
<li>读写分离</li>
<li>容灾恢复</li>
</ul>
<h3 id="怎么玩-2">怎么玩</h3>
<ol>
<li>
<p>配从(库)不配主(库)</p>
</li>
<li>
<p>从库配置：slaveof 主库IP 主库端口</p>
<ul>
<li>每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件</li>
<li>Info replication</li>
</ul>
</li>
<li>
<p>修改配置文件细节操作</p>
<ul>
<li>
<p>拷贝多个redis.conf文件</p>
<figure data-type="image" tabindex="125"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528153928.png" alt="image-20200528153928372" loading="lazy"></figure>
</li>
<li>
<p>开启daemonize yes</p>
<figure data-type="image" tabindex="126"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528153937.png" alt="image-20200528153937412" loading="lazy"></figure>
</li>
<li>
<p>Pid文件名字</p>
</li>
<li>
<p>指定端口</p>
</li>
<li>
<p>Log文件名字</p>
<figure data-type="image" tabindex="127"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528153945.png" alt="image-20200528153945398" loading="lazy"></figure>
</li>
<li>
<p>Dump.rdb名字</p>
<figure data-type="image" tabindex="128"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528153953.png" alt="image-20200528153953166" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>常用3招</p>
<ul>
<li>
<p>一主二仆</p>
<ul>
<li>
<p>Init</p>
<figure data-type="image" tabindex="129"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154124.png" alt="image-20200528154124055" loading="lazy"></figure>
</li>
<li>
<p>一个Master两个Slave</p>
<figure data-type="image" tabindex="130"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154134.png" alt="image-20200528154134404" loading="lazy"></figure>
</li>
<li>
<p>日志查看</p>
<ul>
<li>
<p>主机日志</p>
<figure data-type="image" tabindex="131"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154206.png" alt="image-20200528154206334" loading="lazy"></figure>
</li>
<li>
<p>备机日志</p>
<figure data-type="image" tabindex="132"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154214.png" alt="image-20200528154214600" loading="lazy"></figure>
</li>
<li>
<p>info replication</p>
</li>
</ul>
<figure data-type="image" tabindex="133"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154222.png" alt="image-20200528154221980" loading="lazy"></figure>
</li>
<li>
<p>主从问题演示</p>
<ol>
<li>
<p>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的123是否也可以复制</p>
</li>
<li>
<p>从机是否可以写？set可否？</p>
</li>
<li>
<p>主机shutdown后情况如何？从机是上位还是原地待命</p>
</li>
<li>
<p>主机又回来了后，主机新增记录，从机还能否顺利复制？</p>
</li>
<li>
<p>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>薪火相传</p>
<ul>
<li>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他<br>
slaves的连接和同步请求，那么该slave作为了链条中下一个的master,<br>
可以有效减轻master的写压力</li>
<li>中途变更转向:会清除之前的数据，重新建立拷贝最新的</li>
<li>Slaveof 新主库IP 新主库端口</li>
</ul>
</li>
<li>
<p>反客为主</p>
<ul>
<li>
<p>SLAVEOF no one</p>
<p>使当前数据库停止与其他数据库的同步，转成主数据库。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="复制原理">复制原理</h3>
<ul>
<li>Slave启动成功连接到master后会发送一个sync命令</li>
<li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，<br>
在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li>
<li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li>
<li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li>
</ul>
<h3 id="哨兵模式sentinel">哨兵模式(sentinel)</h3>
<ul>
<li><strong>是什么</strong></li>
</ul>
<blockquote>
<p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p>
</blockquote>
<ul>
<li>
<p><strong>怎么玩(使用步骤)</strong></p>
<ol>
<li>
<p>调整结构，6379带着80、81</p>
</li>
<li>
<p>自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错</p>
</li>
<li>
<p>配置哨兵,填写内容</p>
<ul>
<li>sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1</li>
</ul>
<figure data-type="image" tabindex="134"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154601.png" alt="image-20200528154601200" loading="lazy"></figure>
<ul>
<li>上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机</li>
</ul>
</li>
<li>
<p>启动哨兵</p>
<figure data-type="image" tabindex="135"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154623.png" alt="image-20200528154623843" loading="lazy"></figure>
<ul>
<li>Redis-sentinel /myredis/sentinel.conf</li>
<li>上述目录依照各自的实际情况配置，可能目录不同</li>
</ul>
</li>
<li>
<p>正常主从演示</p>
</li>
<li>
<p>原有的master挂了</p>
<figure data-type="image" tabindex="136"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154633.png" alt="image-20200528154633113" loading="lazy"></figure>
</li>
<li>
<p>投票新选</p>
<figure data-type="image" tabindex="137"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154642.png" alt="image-20200528154642029" loading="lazy"></figure>
</li>
<li>
<p>重新主从继续开工,info replication查查看</p>
<figure data-type="image" tabindex="138"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154649.png" alt="image-20200528154649299" loading="lazy"></figure>
</li>
<li>
<p>问题：如果之前的master重启回来，会不会双master冲突？</p>
<figure data-type="image" tabindex="139"><img src="https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20200528154703.png" alt="image-20200528154703002" loading="lazy"></figure>
</li>
</ol>
</li>
<li>
<p>一组sentinel能同时监控多个Master</p>
</li>
</ul>
<h3 id="复制的缺点">复制的缺点</h3>
<ul>
<li>
<p>复制延时</p>
<p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
</li>
</ul>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://zoengzihaam.github.io/post/7/">
                                <h3 class="post-title">
                                    Linux系统下实现远程连接MySQL数据库
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%8B%E8%BD%BDredis">下载Redis</a></li>
<li><a href="#%E5%AF%B9redis%E7%9A%84%E7%90%86%E8%A7%A3">对Redis的理解</a></li>
<li><a href="#redis%E7%9A%84%E6%A6%82%E8%BF%B0">Redis的概述</a></li>
<li><a href="#%E4%BC%A0%E7%BB%9F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93">传统关系型数据库</a>
<ul>
<li><a href="#1-a-atomicity-%E5%8E%9F%E5%AD%90%E6%80%A7">1、A (Atomicity) 原子性</a></li>
<li><a href="#2-c-consistency-%E4%B8%80%E8%87%B4%E6%80%A7">2、C (Consistency) 一致性</a></li>
<li><a href="#3-i-isolation-%E7%8B%AC%E7%AB%8B%E6%80%A7">3、I (Isolation) 独立性</a></li>
<li><a href="#4-d-durability-%E6%8C%81%E4%B9%85%E6%80%A7">4、D (Durability) 持久性</a></li>
</ul>
</li>
<li><a href="#%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93">非关系型数据库</a>
<ul>
<li><a href="#cconsistency%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7">C:Consistency（强一致性）</a></li>
<li><a href="#aavailability%E5%8F%AF%E7%94%A8%E6%80%A7">A:Availability（可用性）</a></li>
<li><a href="#ppartition-tolerance%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7">P:Partition tolerance（分区容错性）</a></li>
</ul>
</li>
<li><a href="#redis%E7%9A%84%E5%AE%89%E8%A3%85">Redis的安装</a></li>
<li><a href="#redis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">Redis基本使用</a>
<ul>
<li><a href="#%E6%9B%B4%E6%94%B9%E9%85%8D%E7%BD%AE">更改配置</a>
<ul>
<li><a href="#1%E6%9B%B4%E6%94%B9redisconf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">1.更改redis.conf配置文件</a></li>
</ul>
</li>
<li><a href="#%E5%90%AF%E5%8A%A8">启动</a></li>
<li><a href="#%E8%BF%9E%E9%80%9A%E6%B5%8B%E8%AF%95">连通测试</a></li>
<li><a href="#%E5%85%B3%E9%97%ADredis">关闭redis</a></li>
</ul>
</li>
<li><a href="#redis%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98">Redis可能遇到问题</a></li>
<li><a href="#redis%E5%90%AF%E5%8A%A8%E5%90%8E%E6%9D%82%E9%A1%B9%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AE%B2%E8%A7%A3">Redis启动后杂项基础知识讲解</a>
<ul>
<li><a href="#%E5%8D%95%E8%BF%9B%E7%A8%8B">单进程</a></li>
<li><a href="#%E9%BB%98%E8%AE%A416%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93">默认16个数据库</a></li>
<li><a href="#dbsize">DBSIZE</a></li>
<li><a href="#flushdb"><strong>FLUSHDB</strong></a></li>
<li><a href="#flushall">FLUSHALL</a></li>
<li><a href="#%E7%BB%9F%E4%B8%80%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86">统一密码管理</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95">索引</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3">默认端口</a></li>
</ul>
</li>
<li><a href="#redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">Redis数据类型</a>
<ul>
<li><a href="#redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">Redis的五大数据类型</a>
<ul>
<li><a href="#string%E5%AD%97%E7%AC%A6%E4%B8%B2">String（字符串）</a></li>
<li><a href="#hash%E5%93%88%E5%B8%8C%E7%B1%BB%E4%BC%BCjava%E9%87%8C%E7%9A%84map">Hash（哈希，类似java里的Map）</a></li>
<li><a href="#list%E5%88%97%E8%A1%A8">List（列表）</a></li>
<li><a href="#set%E9%9B%86%E5%90%88">Set（集合）</a></li>
<li><a href="#zsetsorted-set%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88">Zset(sorted set：有序集合)</a></li>
</ul>
</li>
<li><a href="#%E5%93%AA%E9%87%8C%E5%8E%BB%E8%8E%B7%E5%BE%97redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">哪里去获得redis常见数据类型操作命令</a></li>
<li><a href="#redis-%E9%94%AEkey">Redis 键(key)</a></li>
<li><a href="#redis%E5%AD%97%E7%AC%A6%E4%B8%B2string">Redis字符串(String)</a></li>
<li><a href="#redis%E5%88%97%E8%A1%A8list">Redis列表(List)</a></li>
<li><a href="#redis%E9%9B%86%E5%90%88set">Redis集合(Set)</a></li>
<li><a href="#redis%E5%93%88%E5%B8%8Chash">Redis哈希(Hash)</a></li>
<li><a href="#redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88zsetsorted-set">Redis有序集合Zset(sorted set)</a></li>
</ul>
</li>
<li><a href="#%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6redisconf">解析配置文件redis.conf</a>
<ul>
<li><a href="#1%E5%AE%83%E5%9C%A8%E5%93%AA">1.它在哪</a></li>
<li><a href="#2units%E5%8D%95%E4%BD%8D">2.Units单位</a></li>
<li><a href="#3includes%E5%8C%85%E5%90%AB">3.INCLUDES包含</a></li>
<li><a href="#4general%E9%80%9A%E7%94%A8">4.GENERAL通用</a>
<ul>
<li><a href="#daemonize">daemonize</a></li>
<li><a href="#pidfile">Pidfile</a></li>
<li><a href="#port">Port</a></li>
<li><a href="#tcp-backlog">Tcp-backlog</a></li>
<li><a href="#timeout">Timeout</a></li>
<li><a href="#bind">Bind</a></li>
<li><a href="#tcp-keepalive">Tcp-keepalive</a></li>
<li><a href="#loglevel">Loglevel</a></li>
<li><a href="#logfile">Logfile</a></li>
<li><a href="#syslog-enabled">Syslog-enabled</a></li>
<li><a href="#syslog-ident">Syslog-ident</a></li>
<li><a href="#syslog-facility">Syslog-facility</a></li>
<li><a href="#databases">Databases</a></li>
</ul>
</li>
<li><a href="#5snapshotting%E5%BF%AB%E7%85%A7">5.SNAPSHOTTING快照</a>
<ul>
<li><a href="#save">Save</a></li>
<li><a href="#stop-writes-on-bgsave-error">Stop-writes-on-bgsave-error</a></li>
<li><a href="#rdbcompression">rdbcompression</a></li>
<li><a href="#rdbchecksum">rdbchecksum</a></li>
<li><a href="#dbfilename">dbfilename</a></li>
<li><a href="#dir">dir</a></li>
</ul>
</li>
<li><a href="#6replication%E5%A4%8D%E5%88%B6">6.REPLICATION复制</a></li>
<li><a href="#7security%E5%AE%89%E5%85%A8">7.SECURITY安全</a></li>
<li><a href="#8limits%E9%99%90%E5%88%B6">8.LIMITS限制</a>
<ul>
<li><a href="#maxclients">Maxclients</a></li>
<li><a href="#maxmemory">Maxmemory</a></li>
<li><a href="#maxmemory-policy">Maxmemory-policy</a></li>
<li><a href="#maxmemory-samples">Maxmemory-samples</a></li>
</ul>
</li>
<li><a href="#9append-only-mode%E8%BF%BD%E5%8A%A0">9.APPEND ONLY MODE追加</a>
<ul>
<li><a href="#appendonly">appendonly</a></li>
<li><a href="#appendfilename">appendfilename</a></li>
<li><a href="#appendfsync">Appendfsync</a></li>
<li><a href="#no-appendfsync-on-rewrite%E9%87%8D%E5%86%99%E6%97%B6%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%BF%90%E7%94%A8appendfsync%E7%94%A8%E9%BB%98%E8%AE%A4no%E5%8D%B3%E5%8F%AF%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7">No-appendfsync-on-rewrite：重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。</a></li>
<li><a href="#auto-aof-rewrite-min-size%E8%AE%BE%E7%BD%AE%E9%87%8D%E5%86%99%E7%9A%84%E5%9F%BA%E5%87%86%E5%80%BC">Auto-aof-rewrite-min-size：设置重写的基准值</a></li>
<li><a href="#auto-aof-rewrite-percentage%E8%AE%BE%E7%BD%AE%E9%87%8D%E5%86%99%E7%9A%84%E5%9F%BA%E5%87%86%E5%80%BC">Auto-aof-rewrite-percentage：设置重写的基准值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96">Redis的持久化</a>
<ul>
<li><a href="#%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D">总体介绍</a>
<ul>
<li><a href="#%E5%AE%98%E7%BD%91%E4%BB%8B%E7%BB%8D">官网介绍</a></li>
</ul>
</li>
<li><a href="#rdbredis-database">RDB（Redis DataBase）</a>
<ul>
<li><a href="#%E5%AE%98%E7%BD%91%E4%BB%8B%E7%BB%8D-2">官网介绍</a></li>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88">是什么：</a></li>
<li><a href="#fork">Fork</a></li>
<li><a href="#rdb-%E4%BF%9D%E5%AD%98%E7%9A%84%E6%98%AFdumprdb%E6%96%87%E4%BB%B6">Rdb 保存的是dump.rdb文件</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E4%BD%8D%E7%BD%AE">配置位置</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91rdb%E5%BF%AB%E7%85%A7">如何触发RDB快照</a>
<ul>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E9%BB%98%E8%AE%A4%E7%9A%84%E5%BF%AB%E7%85%A7%E9%85%8D%E7%BD%AE">配置文件中默认的快照配置</a></li>
<li><a href="#%E5%91%BD%E4%BB%A4save%E6%88%96%E8%80%85%E6%98%AFbgsave">命令save或者是bgsave</a></li>
<li><a href="#%E6%89%A7%E8%A1%8Cflushall%E5%91%BD%E4%BB%A4%E4%B9%9F%E4%BC%9A%E4%BA%A7%E7%94%9Fdumprdb%E6%96%87%E4%BB%B6%E4%BD%86%E9%87%8C%E9%9D%A2%E6%98%AF%E7%A9%BA%E7%9A%84%E6%97%A0%E6%84%8F%E4%B9%89">执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</a></li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D">如何恢复</a></li>
<li><a href="#%E4%BC%98%E5%8A%BF">优势</a></li>
<li><a href="#%E5%8A%A3%E5%8A%BF">劣势</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2">如何停止</a></li>
<li><a href="#%E5%B0%8F%E6%80%BB%E7%BB%93">小总结</a></li>
</ul>
</li>
<li><a href="#aofappend-only-file">AOF（Append Only File）</a>
<ul>
<li><a href="#%E5%AE%98%E7%BD%91%E4%BB%8B%E7%BB%8D-3">官网介绍</a></li>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88-2">是什么：</a></li>
<li><a href="#aof%E4%BF%9D%E5%AD%98%E7%9A%84%E6%98%AFappendonlyaof%E6%96%87%E4%BB%B6">Aof保存的是appendonly.aof文件</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E4%BD%8D%E7%BD%AE-2">配置位置</a></li>
<li><a href="#aof%E5%90%AF%E5%8A%A8%E4%BF%AE%E5%A4%8D%E6%81%A2%E5%A4%8D">AOF启动/修复/恢复</a>
<ul>
<li><a href="#%E6%AD%A3%E5%B8%B8%E6%81%A2%E5%A4%8D">正常恢复</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E6%81%A2%E5%A4%8D">异常恢复</a></li>
</ul>
</li>
<li><a href="#rewrite">Rewrite</a>
<ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88-3">是什么：</a></li>
<li><a href="#%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86">重写原理</a></li>
<li><a href="#%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6">触发机制</a></li>
</ul>
</li>
<li><a href="#%E4%BC%98%E5%8A%BF-2">优势</a>
<ul>
<li><a href="#%E6%AF%8F%E4%BF%AE%E6%94%B9%E5%90%8C%E6%AD%A5">每修改同步：</a></li>
<li><a href="#%E6%AF%8F%E7%A7%92%E5%90%8C%E6%AD%A5">每秒同步：</a></li>
<li><a href="#%E4%B8%8D%E5%90%8C%E6%AD%A5">不同步：</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A3%E5%8A%BF-2">劣势</a></li>
<li><a href="#%E5%B0%8F%E6%80%BB%E7%BB%93-2">小总结</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93which-one">总结(Which one)</a>
<ul>
<li><a href="#%E5%AE%98%E7%BD%91%E5%BB%BA%E8%AE%AE">官网建议</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis%E7%9A%84%E4%BA%8B%E5%8A%A1">Redis的事务</a>
<ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88-4">是什么</a></li>
<li><a href="#%E8%83%BD%E5%B9%B2%E5%98%9B">能干嘛</a></li>
<li><a href="#%E6%80%8E%E4%B9%88%E7%8E%A9">怎么玩</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">常用命令</a></li>
<li><a href="#case1%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C">Case1：正常执行</a></li>
<li><a href="#case2%E6%94%BE%E5%BC%83%E4%BA%8B%E5%8A%A1">Case2：放弃事务</a></li>
<li><a href="#case3%E5%85%A8%E4%BD%93%E8%BF%9E%E5%9D%90">Case3：全体连坐</a></li>
<li><a href="#case4%E5%86%A4%E5%A4%B4%E5%80%BA%E4%B8%BB">Case4：冤头债主</a></li>
<li><a href="#case5watch%E7%9B%91%E6%8E%A7">Case5：watch监控</a></li>
</ul>
</li>
<li><a href="#3%E9%98%B6%E6%AE%B5">3阶段</a>
<ul>
<li><a href="#%E5%BC%80%E5%90%AF">开启：</a></li>
<li><a href="#%E5%85%A5%E9%98%9F">入队：</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C">执行：</a></li>
</ul>
</li>
<li><a href="#3%E7%89%B9%E6%80%A7">3特性</a>
<ul>
<li><a href="#%E5%8D%95%E7%8B%AC%E7%9A%84%E9%9A%94%E7%A6%BB%E6%93%8D%E4%BD%9C">单独的隔离操作：</a></li>
<li><a href="#%E6%B2%A1%E6%9C%89%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E6%A6%82%E5%BF%B5">没有隔离级别的概念：</a></li>
<li><a href="#%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7">不保证原子性：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85">Redis的发布订阅</a>
<ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88-5">是什么</a></li>
<li><a href="#%E5%91%BD%E4%BB%A4">命令</a></li>
<li><a href="#%E6%A1%88%E4%BE%8B">案例</a></li>
</ul>
</li>
<li><a href="#redis%E7%9A%84%E5%A4%8D%E5%88%B6masterslave">Redis的复制(Master/Slave)</a>
<ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88-6">是什么</a>
<ul>
<li><a href="#%E5%AE%98%E7%BD%91">官网</a></li>
<li><a href="#%E8%A1%8C%E8%AF%9D">行话：</a></li>
</ul>
</li>
<li><a href="#%E8%83%BD%E5%B9%B2%E5%98%9B-2">能干嘛</a></li>
<li><a href="#%E6%80%8E%E4%B9%88%E7%8E%A9-2">怎么玩</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86">复制原理</a></li>
<li><a href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8Fsentinel">哨兵模式(sentinel)</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9">复制的缺点</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://zoengzihaam.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
        
            <script>
    window.onload = function() {
        var gitalk = new Gitalk({
            clientID: '049ef8314a6b421eb956',
            clientSecret: '663d9d7b41b952b25ca2ea0e38cd6ae061bd63c2',
            repo: 'GitalkDatabase',
            owner: 'zoengzihaam',
            admin: ['zoengzihaam'],
            id: (location.pathname).substring(0, 49), // Ensure uniqueness and length less than 50
            distractionFreeMode: false // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    }
</script>
                

                    
                                
</body>

</html>