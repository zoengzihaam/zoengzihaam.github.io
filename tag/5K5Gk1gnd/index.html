<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    Redis | 卷毛
</title>
<link rel="shortcut icon" href="https://zoengzihaam.github.io/favicon.ico?v=1610626426697">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zoengzihaam.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://zoengzihaam.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://zoengzihaam.github.io">
                <img class="avatar" src="https://zoengzihaam.github.io/images/avatar.png?v=1610626426697" alt="">
            </a>
            <div class="site-title">
                <h1>
                    卷毛
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        Redis</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zoengzihaam.github.io/post/8/">
                        Redis
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-06-04</time>
                    
                        <a href="https://zoengzihaam.github.io/tag/5K5Gk1gnd/" class="post-tag i-tag
                            i-tag-error">
            #Redis
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
多能，数据类型丰富，使用Redis，Tair
Redis:REmote DIctionary Server(远程字典服务器)
是完全开源免费的，用C语言编写的，遵守BSD协议，
是一个高性能的(key/value)分布式内存数据库，基于内存运行
并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,
也被人们称为数据结构服务器

下载Redis
https://redis.io/download
对Redis的理解

Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。
KV、Cache、Persistence、...

Redis的概述

3V+3高




3V
3高




海量Volume
高并发


多样Variety
高可扩


实时Velocity
高性能



传统关系型数据库
传统的ACID
1、A (Atomicity) 原子性
原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。
2、C (Consistency) 一致性
一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。
3、I (Isolation) 独立性
所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的
4、D (Durability) 持久性
持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。
非关系型数据库
CAP
C:Consistency（强一致性）
A:Availability（可用性）
P:Partition tolerance（分区容错性）
Redis的安装

Linux版安装



获取Redis的安装包
将安装包放在/usr/local/redis下


解压Redis安装包


tar -zxvf redis-5.0.4.tar.gz


进入Redis目录

cd /usr/local/redis/redis-5.0.4


执行make命令

make

运行make命令时故
意出现的错误解析：
​	安装gcc
yum -y install gcc-c++


执行make install，检验安装

make install

Redis基本使用
更改配置
1.更改redis.conf配置文件
首先备份当前redis.conf文件，修改以下内容。
daemonize yes

启动
安装redis之后，在/usr/local/bin会有redis的启动文件。


执行redis-server /bak/redis/redis.conf，启动redis并使用指定的配置文件。

redis-server /bak/redis/redis.conf


连通测试

执行redis-cli -p 6379来指定端口启动测试。

redis-cli -p 6379


使用ping命令来测试连通，出现PONG即为成功。



可使用ps -ef|grep redis来查看redis的进程。

ps -ef|grep redis


关闭redis

执行redis-cli shutdown。

redis-cli shutdown

Redis可能遇到问题

修改配置文件

protected-mode no # 关闭保护模式
daemonize yes     # 守护进程模式开启
#bind 127.0.0.1   # 绑定IP按需修改
port 6379         # 端口按需修改


运行并检查端口

#启动服务命令
./usr/local/bin/redis-server /bak/redis/redis.conf
#查看6379端口是否占用
netstat -tunpl | grep 6379


开放防火墙端口

#开放6379端口
/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT
#保存配置
/etc/rc.d/init.d/iptables save
#重启服务
/etc/rc.d/init.d/iptables restart
#查看端口是否已经开放
/etc/init.d/iptables status

Redis启动后杂项基础知识讲解
单进程

单进程模型来处理客户端的请求。对读写等事件的响应
是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率


Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，
它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。

默认16个数据库


默认16个数据库，类似数组下表从零开始，初始默认使用零号库。
可以使用select &amp;lt;id&amp;gt;来连接指定数据库id



DBSIZE

Dbsize查看当前数据库的key的数量

DBSIZE



使用keys *可查看当前库中的key

keys *


FLUSHDB

清空当前库

FLUSHDB


FLUSHALL

通杀全部库

FLUSHALL


统一密码管理
索引

Reids索引都是从零开始

默认端口

默认端口是6379

Redis数据类型
Redis的五大数据类型
String（字符串）
String（字符串）
string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。
string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。
string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M
Hash（哈希，类似java里的Map）
Hash（哈希）
Redis hash 是一个键值对集合。
Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。
类似Java里面的Map&amp;lt;String,Object&amp;gt;
List（列表）
List（列表）
Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。
它的底层实际是个链表
Set（集合）
Redis的Set是string类型的无序集合。它是通过HashTable实现实现的。
Zset(sorted set：有序集合)
zset(sorted set：有序集合)
Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
不同的是每个元素都会关联一个double类型的分数。
redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。
哪里去获得redis常见数据类型操作命令

Http://redisdoc.com/





Redis 键(key)

常用




案例

keys *



exists key的名字，判断某个key是否存在。



move key db，移动当前库的key到指定的库中。



expire key，给指定的key设置一个过期时间。



ttl key，查看当前key的过期时间，-1表示永不过期，-2表示已过期。

当key过期的时候，代表当前key的生命周期已经结束，所以在当前库中就不存在这个key。


type key，查看当前的key的类型。



del key，删除当前的key




Redis字符串(String)

常用





单值单value


案例

set key value，设置一个K,V



get key，获取当前key的value值。



append key value，在指定key的value值后添加指定的值。



strlen key，查询当前key的长度。



incr key，对当前的key进行递增。



decr key，对当前的key进行递减。




incrby key num，对当前的key进行指定数字的递增。

decrby key num，对当前的key进行指定数字的递减。

**注意：**一定要是数字才能进行加减。
getrange key start end，获取当前key字符串的指定长度内容。

setrange key index str，设置当前key字符串指定下标开始，设置str内容。

setex key second valuesetex(set with expire)，设置K,V，并设置到期时间。

setnx key value，setnx(set if not exist)，只有当前key不存在的时候，设置key的值。

mset key1 value1 key2 value2 key3 value3，设置多个K,V。

mget key1 key2 key3，获取多个指定key的值。

msetnx key1 value1 key2 value2 key3 value3，设置多个值，当设置key不存在时，设置指定key值，如果一个不存在，则都不设置。

Redis列表(List)

常用





单值多value


案例

lpush key value1 [value2]，将一个或多个值插入到列表头部。




rpush key value1 [value2]，在列表中添加一个或多个值

lrange key start end，获取列表指定范围内的元素

lpop key，移除并获取列表的第一个元素

rpop key，移除并获取列表最后一个元素。

lindex key index，根据下标，查询执行列表中的数据。

llen key，查询指定列表的长度

lrem key count value，移除指定列表指定数量的值。

ltrim key start end，截取指定列表的指定下标内容，然后赋值给这个列表。

rpoplpush source destination，移除列表的最后一个元素，并将该元素添加到另一个列表并返回。

lset key index value，通过索引设置列表元素的值。

linsert key before|after pivot value，在列表的元素前或者后插入元素。

Redis集合(Set)

常用




单值多value


案例

sadd key member1 [member2]，向集合添加一个或多个成员。



smembers key，返回集合中的所有成员



sismember key member，判断 member 元素是否是集合key的成员。



scard key，获取集合的成员数



srem key member1 [member2]，移除集合中一个或多个成员



srandmember key [count]，返回集合中一个或多个随机数。



spop key，移除并返回集合中的一个随机元素



smove key1 key2 member，将member元素从key1集合移动到key2集合。




数学集合类

sdiff key1 [key2]，返回给定所有集合的差集。（在第一个set里面而不在后面任何一个set里面的项）



sinter key1 [key2]，返回给定所有集合的交集。



sunion key1 [key2]，返回所有给定集合的并集。






Redis哈希(Hash)

常用




KV模式不变，但V是一个键值对。


案例

hset key field value，将哈希表key中 的字段field的值设为value。



hget key field，获取存储在哈希表中指定field字段的值。



hmset key field1 value1 [field2 value2]，同时将多个field-value(域-值)对设置到哈希表key中。



hgetall key，获得存储在哈希表中指定key的所有字段和值。



hdel key field，删除存储在哈希表中key 指定字段。



hexists key field，查询存储在哈希表中指定字段是否存在



hkeys key，获取所有哈希表中的字段



hvals keys，获取哈希表中所有的值。



hincrby key field increment，为哈希表key中的指定字段的整数值加上增量increment。



hincrbyfloat key field increment，为哈希表中的指定字段的浮点数值加上增量increment。



hsetnx key field value，只有在字段field不存在时，设置哈希表字段的值。




Redis有序集合Zset(sorted set)

常用





案例

zadd key score1 member1 [score2 member2]，向有序集合添加一个或多个成员，或者更新已存在成员的分数。



zrangebyscore key start end，通过分数返回有序集合指定区间内的成员。



zrangebyscore key (start end，通过返回有序集合指定区间内(带有(，说明不包含)的成员。



zrem key member，根据对应的value值删除有序集合中的成员元素。



zcard key，获得有序列表中的成员数。



zcount key min max，查询在有序列表中指定区间的成员数。



zrank key value，获取指定成员在有序列表中的下标。



zscore key value，获取有序列表中指定成员的值。



zrevrank key values，逆序获得下标值。




解析配置文件redis.conf
1.它在哪


地址。
进入redis目录下，使用pwd命令来查看当前目录。





为什么拷贝出来单独执行？
通常为了配置的安全，放置在原文件配置错误，导致无法正常运行。


2.Units单位

3.INCLUDES包含

和其他配置文件一样，可以通过includes包含，redis.conf可以作为总闸，包含其他。


4.GENERAL通用
daemonize

介绍

A、redis.conf配置文件中daemonize守护线程，默认是NO。
B、daemonize是用来指定redis是否要用守护线程的方式启动。


daemonize 设置yes或者no区别

daemonize:yes:redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。
daemonize:no: 当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。



Pidfile

当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定。

Port

指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字。

Tcp-backlog


文档解释
tcp-backlog
设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。
在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值来达到想要的效果。


Timeout

当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能。

Bind

绑定的主机地址

Tcp-keepalive

单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60。

Loglevel

指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice

Logfile

指定日志文件的路径。

Syslog-enabled

是否把日志输出到syslog中。默认是no。

Syslog-ident

指定syslog里的日志标志。默认是redis。

Syslog-facility

指定syslog设备，值可以是USER或LOCAL0-LOCAL7。默认是LOCAL0。

Databases

设置数据库的数量，默认数量为16，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id。

5.SNAPSHOTTING快照
Save

save 秒钟 写操作次数

RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，
默认
是1分钟内改了1万次，
或5分钟内改了10次，
或15分钟内改了1次。


禁用

如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。


如果想即可备份，使用save命令，可执行立即备份功能。

Stop-writes-on-bgsave-error
如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制。

rdbcompression
rdbcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用
LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能
rdbchecksum
dbfilename
dir
6.REPLICATION复制
7.SECURITY安全

访问密码的查看、设置和取消。


8.LIMITS限制
Maxclients

设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当你
无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自
身内部处理逻辑留一些句柄出来。如果达到了此限制，redis则会拒绝新的连接请求，并且向这
些连接请求方发出“max number of clients reached”以作回应。

Maxmemory


设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，
那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。
但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。


Maxmemory-policy

（1）volatile-lru：使用LRU算法移除key，只对设置了过期时间的键。
（2）allkeys-lru：使用LRU算法移除key。
（3）volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键。
（4）allkeys-random：移除随机的key。
（5）volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key。
（6）noeviction：不进行移除。针对写操作，只是返回错误信息。

Maxmemory-samples

设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，
redis默认会检查这么多个key并选择其中LRU的那个。

9.APPEND ONLY MODE追加
appendonly
appendfilename
Appendfsync


Always：同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好。
Everysec：出厂默认推荐，异步操作，每秒记录   如果一秒内宕机，有数据丢失。
No

No-appendfsync-on-rewrite：重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。
Auto-aof-rewrite-min-size：设置重写的基准值
Auto-aof-rewrite-percentage：设置重写的基准值
Redis的持久化
总体介绍
官网介绍

RDB（Redis DataBase）
官网介绍

是什么：

在指定的时间间隔内将内存中的数据集快照写入磁盘，
也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。
Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到
一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。
整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能
如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方
式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。

Fork

Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）
数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。

Rdb 保存的是dump.rdb文件
配置位置

如何触发RDB快照
配置文件中默认的快照配置



冷拷贝后重新使用
可以cp dump.rdb dump_new.rdb


命令save或者是bgsave

Save：save时只管保存，其它不管，全部阻塞



BGSAVE：Redis会在后台异步进行快照操作，
快照同时还可以响应客户端请求。可以通过lastsave
命令获取最后一次成功执行快照的时间

执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义
如何恢复


将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可


CONFIG GET dir获取目录


优势

适合大规模的数据恢复
对数据完整性和一致性要求不高

劣势

在一定间隔时间做一次备份，所以如果redis意外down掉的话，就
会丢失最后一次快照后的所有修改
Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑

如何停止

动态所有停止RDB保存规则的方法：redis-cli config set save &amp;quot;&amp;quot;

小总结

AOF（Append Only File）
官网介绍

是什么：

以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，
只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

Aof保存的是appendonly.aof文件
配置位置

AOF启动/修复/恢复
正常恢复

启动：设置Yes
修改默认的appendonly no，改为yes
将有数据的aof文件复制一份保存到对应目录(config get dir)。
恢复：重启redis然后重新加载。

异常恢复

启动：设置Yes
修改默认的appendonly no，改为yes。
备份被写坏的AOF文件
修复：Redis-check-aof --fix进行修复
恢复：重启redis然后重新加载

Rewrite

是什么：

AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,
当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，
只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof

重写原理
AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，
遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，
而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。
触发机制
Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。
优势
每修改同步：
appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好。
每秒同步：
appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失
不同步：
appendfsync no   从不同步。
劣势

相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb。
Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同。

小总结

总结(Which one)
官网建议



RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。


AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些
命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.
Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。


只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式。


同时开启两种持久化方式。

在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,
因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？
作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，
快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。



性能建议。


因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。
如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。
如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构。




Redis的事务
是什么

可以一次执行多个命令，本质是一组命令的集合。一个事务中的
所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞。


官网


能干嘛

一个队列中，一次性、顺序性、排他性的执行一系列命令。

怎么玩

常用命令

Case1：正常执行

Case2：放弃事务

Case3：全体连坐

Case4：冤头债主

Case5：watch监控


悲观锁/乐观锁/CAS(Check And Set)


悲观锁
悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。


乐观锁
乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，
乐观锁策略:提交版本必须大于记录当前版本才能执行更新。


CAS




初始化信用卡可用余额和欠额



无加塞篡改，先监控再开启multi，保证两笔金额变动在同一个事务内。



有加塞篡改。



unwatch



一旦执行了exec之前加的监控锁都会被取消掉了


小结

Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变，
比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行。
通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，
EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。



3阶段
开启：
以MULTI开始一个事务。
入队：
将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面
执行：
由EXEC命令触发事务
3特性
单独的隔离操作：
事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
没有隔离级别的概念：
队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，
也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题
不保证原子性：
redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚
Redis的发布订阅
是什么


进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。


订阅/发布消息图



命令

案例
先订阅后发布后才能收到消息，


可以一次性订阅多个，SUBSCRIBE c1 c2 c3



消息发布，PUBLISH c2 hello-redis



订阅多个，通配符*， PSUBSCRIBE new*




收取消息， PUBLISH new1 redis2015。


Redis的复制(Master/Slave)
是什么
官网

行话：
也就是我们所说的主从复制，主机数据更新后根据配置和策略，
自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主
能干嘛

读写分离
容灾恢复

怎么玩


配从(库)不配主(库)


从库配置：slaveof 主库IP 主库端口

每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件
Info replication



修改配置文件细节操作


拷贝多个redis.conf文件



开启daemonize yes



Pid文件名字


指定端口


Log文件名字



Dump.rdb名字





常用3招


一主二仆


Init



一个Master两个Slave



日志查看


主机日志



备机日志



info replication





主从问题演示


切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的123是否也可以复制


从机是否可以写？set可否？


主机shutdown后情况如何？从机是上位还是原地待命


主机又回来了后，主机新增记录，从机还能否顺利复制？


其中一台从机down后情况如何？依照原有它能跟上大部队吗？






薪火相传

上一个Slave可以是下一个slave的Master，Slave同样可以接收其他
slaves的连接和同步请求，那么该slave作为了链条中下一个的master,
可以有效减轻master的写压力
中途变更转向:会清除之前的数据，重新建立拷贝最新的
Slaveof 新主库IP 新主库端口



反客为主


SLAVEOF no one
使当前数据库停止与其他数据库的同步，转成主数据库。






复制原理

Slave启动成功连接到master后会发送一个sync命令
Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，
在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步
全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。
增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步
但是只要是重新连接master,一次完全同步（全量复制)将被自动执行

哨兵模式(sentinel)

是什么


反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库



怎么玩(使用步骤)


调整结构，6379带着80、81


自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错


配置哨兵,填写内容

sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1



上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机



启动哨兵


Redis-sentinel /myredis/sentinel.conf
上述目录依照各自的实际情况配置，可能目录不同



正常主从演示


原有的master挂了



投票新选



重新主从继续开工,info replication查查看



问题：如果之前的master重启回来，会不会双master冲突？





一组sentinel能同时监控多个Master


复制的缺点


复制延时
由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。



                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zoengzihaam.github.io/post/8/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://zoengzihaam.github.io/images/avatar.png?v=1610626426697)">
        </div>
        <h1 class="id_card-title">
            卷毛
        </h1>
        <h2 class="id_card-description">
            没有撤退可言。
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://zoengzihaam.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>