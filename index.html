<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    卷毛
</title>
<link rel="shortcut icon" href="https://zoengzihaam.github.io/favicon.ico?v=1610626506137">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zoengzihaam.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://zoengzihaam.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://zoengzihaam.github.io">
                <img class="avatar" src="https://zoengzihaam.github.io/images/avatar.png?v=1610626506137" alt="">
            </a>
            <div class="site-title">
                <h1>
                    卷毛
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zoengzihaam.github.io/post/netflixdns-jie-suo/">
                        NetflixDNS解锁
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2021-01-12</time>
                    
                        <a href="https://zoengzihaam.github.io/tag/g80SHtBSX/" class="post-tag i-tag
                            i-tag-error">
            #Netflix
        </a>
                        
                        <a href="https://zoengzihaam.github.io/tag/nT7uo7T7GH/" class="post-tag i-tag
                            i-tag-other_3">
            #VPS
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://zoengzihaam.github.io/post/netflixdns-jie-suo/" class="post-feature-image" style="background-image:url(https://gitee.com/zoengzihaam/ImgBed/raw/master/images/20210114201328.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            NetflixDNS解锁

由于Netflix的版权问题，使用一般的代理服务跨区看剧时会被 Netflix 检测到并阻止，当我们使用的vps不能观看Netflix的时候，我们可以选择购买便宜大碗的vps来辅助解锁不能查看Netflix的vps。

准备工作
正式开始之前，我们需要做一些基本的准备，你至少需要这些东西：

支持 Netflix 的代理服务
不支持 Netflix 的代理服务
Netflix订阅

就目前而言，美区应该是目前剧集资源最丰富的地区，但是根据本人亲测，美区的资源并不符合国人的观看风格，个人比较推荐香港。
使用Dnsmasq解锁Netflix（奈飞）流媒体服务
这里借助了萌精灵 的脚本实现，这里感谢萌精灵。
安装方法：
支持 Netflix 的代理vps安装
wget --no-check-certificate -O dnsmasq_sniproxy.sh https://raw.githubusercontent.com/myxuchangbin/dnsmasq_sniproxy_install/master/dnsmasq_sniproxy.sh &amp;amp;&amp;amp; bash dnsmasq_sniproxy.sh -f

卸载方法：
wget --no-check-certificate -O dnsmasq_sniproxy.sh https://raw.githubusercontent.com/myxuchangbin/dnsmasq_sniproxy_install/master/dnsmasq_sniproxy.sh &amp;amp;&amp;amp; bash dnsmasq_sniproxy.sh -u

使用方法：
将不支持 Netflix 的代理VPS的DNS地址修改为支持 Netflix 的代理vps的IP就可以了，如果不能用，记得只保留一个DNS地址试一下。
⚠️：防止滥用，建议不要随意公布IP地址，或使用防火墙做好限制工作。
调试排错：

确认sniproxy有效运行

重启sni命令：systemctl restart sniproxy
如果sni不在运行，可检查配置/etc/sniproxy.conf，避免ss、nginx或者其他程序监听80,443，可将其配置文件的80更改为801等。 443端口必须给sni监听放行，查看：netstat -tlunp|grep 443

确认防火墙放行443,53

调试可直接关闭防火墙 systemctl stop firewalld.service
阿里云/谷歌云/AWS等外部防火墙放行 可通过其他服务器 telnet vpsip 53 以及 telnet vpsip 443 进行测试

解析域名

尝试用其他服务器配置完毕dns后，解析域名：nslookup netflix.com 判断IP是否是NETFLIX代理机器IP 如果不存在nslookup命令，CENTOS安装：yum install -y bind-utils，DEBIAN安装：apt-get -y install dnsutils
一键脚本修改推荐修改方式：

一键脚本很多都会自带dns服务，会影响流媒体的dns解锁。

修改方式：
vi /etc/v2ray/config.json

找到DNS
&amp;quot;dns&amp;quot;: {
        &amp;quot;servers&amp;quot;: [
            {
                &amp;quot;address&amp;quot;: &amp;quot;xxx.xxx.xxx.xxx&amp;quot;,     //此处为支持 Netflix 的代理VPS
                &amp;quot;port&amp;quot;: 53,
                &amp;quot;domains&amp;quot;: [
                    &amp;quot;domain:netflix.com&amp;quot;,
                    &amp;quot;domain:netflix.net&amp;quot;,
                    &amp;quot;domain:nflximg.net&amp;quot;,
                    &amp;quot;domain:nflxvideo.net&amp;quot;,
                    &amp;quot;domain:nflxso.net&amp;quot;,
                    &amp;quot;domain:nflxext.com&amp;quot;
                ]
            },
            &amp;quot;localhost&amp;quot;
        ]
    }

修改配置完成以后，请重启你的V2RAY服务，或是重启VPS。
使用分流，让不同的流媒体走不同的DNS
修改方法：
&amp;quot;dns&amp;quot;: {
        &amp;quot;servers&amp;quot;: [
            {
                &amp;quot;address&amp;quot;: &amp;quot;支持Netflix的代理VPS&amp;quot;,
                &amp;quot;port&amp;quot;: 53,
                &amp;quot;domains&amp;quot;: [
                    &amp;quot;domain:netflix.com&amp;quot;,
                    &amp;quot;domain:netflix.net&amp;quot;,
                    &amp;quot;domain:nflximg.net&amp;quot;,
                    &amp;quot;domain:nflxvideo.net&amp;quot;,
                    &amp;quot;domain:nflxso.net&amp;quot;,
                    &amp;quot;domain:nflxext.com&amp;quot;
                ]
            },
            {
                &amp;quot;address&amp;quot;: &amp;quot;支持的代理VPS&amp;quot;,
                &amp;quot;port&amp;quot;: 53,
                &amp;quot;domains&amp;quot;: [
                    &amp;quot;domain:gamer2-cds.cdn.hinet.net&amp;quot;,
                    &amp;quot;domain:gamer-cds.cdn.hinet.net&amp;quot;,
                    &amp;quot;domain:gamer.com.tw&amp;quot;,
                    &amp;quot;domain:i2.bahamut.com.tw&amp;quot;,
                    &amp;quot;domain:app-measurement.com&amp;quot;
                ]
            },
            {
                &amp;quot;address&amp;quot;: &amp;quot;支持的代理VPS&amp;quot;,
                &amp;quot;port&amp;quot;: 53,
                &amp;quot;domains&amp;quot;: [
                    &amp;quot;domain:bilibili.com&amp;quot;
                ]
            },
            &amp;quot;localhost&amp;quot;
        ]
    }


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zoengzihaam.github.io/post/netflixdns-jie-suo/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zoengzihaam.github.io/post/19/">
                        ROS双软路由使用jump实现公网端口转发
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-11-25</time>
                    
                        <a href="https://zoengzihaam.github.io/tag/yqutSJDYyB/" class="post-tag i-tag
                            i-tag-">
            #life
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
由于使用了双软路由，ROS上设置upnp，端口不能实现自动转发，所以使用ROS的jump方式来实现这个功能。


首先在ROS功能界面打开 IP → Firewall → NAT




添加一个 NAT 规则 (设置jump)
1️⃣ General 设置

2️⃣ Action 设置



设置需要的端口转发
1️⃣ 添加一个 NAT 规则 (General 设置)

2️⃣ Action 设置

到此端口转发就设置完成。


番外

由于公网每次拨号，可能导致公网地址会发生改变，这里使用ROS的脚本来实现自动设置JUMP里面的公网地址。

1️⃣ 在ROS界面 System → scripts 添加一个脚本

2️⃣ 设置脚本

script脚本代码：
:global addold
:global addnew
 :set addnew [/interface get [/interface find name=&amp;quot;pppoe-out1&amp;quot;] running]
 :if ($addnew=true) do={
  :set addold [/ip address get [/ip address find dynamic=yes interface=&amp;quot;pppoe-out1&amp;quot;] address]
  :set addold [:pick $addold 0 ([:len $addold ] -3)]
   /ip firewall nat set [/ip firewall nat find comment=&amp;quot;dynamic_nat&amp;quot;] dst-address=$addold
}

3️⃣ 设置一个定时Profile
ROS界面 → PPP → Profiles 添加一个新的Profile

设置Profiles

设置 Scripts

profile脚本代码：
delay 3s
:execute &amp;quot;dynamic_nat&amp;quot;



🌈以上，公网端口转发的jump设置全部设置完毕，如果过程有错误的地方，还请各位指教一起讨论，谢谢。💨

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zoengzihaam.github.io/post/19/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zoengzihaam.github.io/post/16/">
                        docker开机自启
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-07-25</time>
                    
                        <a href="https://zoengzihaam.github.io/tag/bV_DFMXGZ/" class="post-tag i-tag
                            i-tag-error">
            #Docker
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            docker开机自启
一、docker服务设置自动启动

适用于yum安装的各种服务


查看已启动的服务

systemctl list-units --type=service


查看是否设置开机启动

systemctl list-unit-files | grep enable


设置开机启动

systemctl enable docker.service


关闭开机启动

systemctl disable docker.service

二、docker容器设置自动启动

启动时加 --restart=always

docker run tomcat -it -d -p 8080:8080 --restart=always



如果已经运行过的项目
针对：已经启动的项目，使用update更新


docker update --restart=always imagesID

restart参数的启动选项



Flag
Description




no
不自动重启容器. (默认value)


on-failure
容器发生error而退出(容器退出状态不为0)重启容器


unless-stopped
在容器已经stop掉或Docker stoped/restarted的时候才重启容器


always
在容器已经stop掉或Docker stoped/restarted的时候才重启容器




转载至：秋寻草

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zoengzihaam.github.io/post/16/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zoengzihaam.github.io/post/15/">
                        Docker安装GUI图形化界面（Portainer）
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-07-25</time>
                    
                        <a href="https://zoengzihaam.github.io/tag/bV_DFMXGZ/" class="post-tag i-tag
                            i-tag-warning">
            #Docker
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            Docker安装GUI图形化界面（Portainer）

Portainer是一个开源、轻量级Docker管理用户界面，基于Docker API，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型单位对容器管理的全部需求。

快速入门
1.官网
https://www.portainer.io/installation/
2.使用docker安装portainer
1.搜索portainer
docker search portainer


2.将镜像拉取到本地
docker pull portainer/portainer


3.运行镜像
docker run -d -it --name portainerUI -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer


注意：这里如果使用单机版，一定要使用 -v /var/run/docker.sock:/var/run/docker.sock，否则在进入WEBUI的时候创建会出现问题，这里 volume也可使用官方教程，这里将运行代码一并贴入。
docker volume create portainer_data
docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer

官方这里创建了一个portainer_data的文件夹用于存储数据，大家按需运行即可。
3.访问Portainer
1.创建用户
打开浏览器输入 ip:端口号，这里ip是Linux的地址，端口号为启动的时候映射的端口。

2.连接docker环境

3.进入Portainer管理


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zoengzihaam.github.io/post/15/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zoengzihaam.github.io/post/13/">
                        GateWay自定义全局GlobalFilter
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-07-06</time>
                    
                        <a href="https://zoengzihaam.github.io/tag/hR2Q3InCJ/" class="post-tag i-tag
                            i-tag-other_1">
            #spring
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            GateWay自定义全局GlobalFilter
1.实现两个接口


GlobalFilter
用于自定义过滤器，例如进行Token验证


Ordered
Spring提供了Ordered这个接口，来处理相同接口实现类的优先级问题。


import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.Date;

@Component
@Slf4j
public class MyLogGateWayFilter implements GlobalFilter, Ordered {

    @Override
    public Mono&amp;lt;Void&amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {

        //打印输出信息
        log.info(&amp;quot;************come in MyLogGateWayFilter&amp;quot; + new Date());

        //获取request中的参数
        String name = exchange.getRequest().getQueryParams().getFirst(&amp;quot;name&amp;quot;);
        //判断参数的信息
        if(name ==null){
            log.info(&amp;quot;************用户名为null，非法用户，/(ㄒoㄒ)/~~&amp;quot;);
            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);
            return exchange.getResponse().setComplete();
        }

        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return 0;
    }
}

2. 使用CMD验证


遵循过滤器中的规则



不遵循过滤器中的规则



3.网页端测试


遵循过滤器中的规则



不遵循过滤器中的规则



结论：自定义Filter类似SpringMVC中的Filter，GlobalGilter 全局过滤器接口与 GatewayFilter 网关过滤器接口具有相同的方法定义。全局过滤器是一系列特殊的过滤器，会根据条件应用到所有路由中。网关过滤器是更细粒度的过滤器，作用于指定的路由中。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zoengzihaam.github.io/post/13/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zoengzihaam.github.io/post/12/">
                        微服务中使用GateWay实现保护、增强和控制对于 API 服务的访问。
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-07-06</time>
                    
                        <a href="https://zoengzihaam.github.io/tag/hR2Q3InCJ/" class="post-tag i-tag
                            i-tag-error">
            #spring
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            微服务中使用GateWay实现保护、增强和控制对于 API 服务的访问。

网关的角色是作为一个 API 架构，用来保护、增强和控制对于 API 服务的访问。
API 网关是一个处于应用程序或服务（提供 REST API 接口服务）之前的系统，用来管理授权、访问控制和流量限制等，这样 REST API 接口服务就被 API 网关保护起来，对所有的调用者透明。因此，隐藏在 API 网关后面的业务系统就可以专注于创建和管理服务，而不用去处理这些策略性的基础设施。

简单使用
三个概念

注：上图引用CSDN博主AlgoRain，这里致谢一下大佬详细的讲解。
springcloud中使用
1.新建Module
添加一个新的Module，cloud-gateway-gateway9527（名称按照自己喜好）
2.添加POM依赖
&amp;lt;dependencies&amp;gt;
        &amp;lt;!--gateway--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-gateway&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Eureka client--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--导入自己定义的api通用包--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.ziznah.springcloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;cloud-api-commons&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--一般基础配置类--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;

3.添加YML文件
#配置端口
server:
  port: 9527

spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      routes:
        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001          #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**         # 断言，路径相匹配的进行路由

        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001          #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
#注册进服务中心，这里使用的是eureka
eureka:
  instance:
    hostname: cloud-gateway-service
  client: #服务提供者provider注册进eureka服务列表内
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://localhost:7001/eureka/


4.主启动类
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
@EnableDiscoveryClient
public class GateWayMain9527 {
    public static void main(String[] args) {
        SpringApplication.run(GateWayMain9527.class,args);
    }
}

使用配置类来简单使用GateWay

将http://localhost:9527/guonei转发到百度的新闻网中的国内信息

import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GateWayConfig {

    /**
     * 配置一个id为route-name的路由规则，
     * 当访问地址http://localhost:9527/guonei时会自动转发到地址：http://news.baidu.com/guonei
     * @param routeLocatorBuilder
     * @return
     */
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder){
        //获取网关的routes
        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();
        //设置网关的内容
        routes.route(&amp;quot;path_route_ziznah&amp;quot;,r -&amp;gt; r.path(&amp;quot;/guonei&amp;quot;).uri(&amp;quot;http://news.baidu.com/guonei&amp;quot;)).build();

        //返回内容
        return routes.build();
    }
}

实现动态路由

多个服务提供者进行提供服务，使用动态路由来到达负载均衡

1.YML
server:
  port: 9527

spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
     #开启动态创建路由的功能
      discovery:
        locator:
          enabled: true   #开启从注册中心动态创建路由的功能，利用微服务名进行路由
      routes:
        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
#          uri: http://localhost:8001          #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service   #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**         # 断言，路径相匹配的进行路由

        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
#          uri: http://localhost:8001          #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service   #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由

eureka:
  instance:
    hostname: cloud-gateway-service
  client: #服务提供者provider注册进eureka服务列表内
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://localhost:7001/eureka/

注：需要注意的是uri的协议lb，表示启用Gateway的负载均衡功能，lb://serverName是spring cloud  gatway在微服务中自动为我们创建的负载均衡uri。
predicates断言不同类型
1.After

YML文件

# 断言，路径相匹配的进行路由
predicates:		
	- After=2020-07-06T16:43:08.146+08:00[Asia/Shanghai]

上述的时间地址可使用Java中time的api来获取：
import java.time.ZoneId;
import java.time.ZonedDateTime;

public class T2 {
    public static void main(String[] args) {
        //获取默认时区
        ZonedDateTime zdt = ZonedDateTime.now();
        System.out.println(zdt);
        //通过指定时区获取当前时间
        ZonedDateTime now = ZonedDateTime.now(ZoneId.of(&amp;quot;America/New_York&amp;quot;));
        System.out.println(now);
    }
}


2.Before
方法同After
3.Between
方法同After
4.Cookie

YML文件

# 断言，路径相匹配的进行路由
predicates:		
	- Cookie=ceshi,admin	

Windows中CMD窗口使用curl命令进行http请求

不带Cookie进行访问测试。



带Cookie进行访问测试。


5.Header

YML文件

# 断言，路径相匹配的进行路由
predicates:		
	- Header=X-Request-Id, \d+		#请求头要有X-Request-Id属性，并且值为正数的正则表达式。

使用CMD的curl命令测试

带Header




不带Header



带错误的Header信息



6.Host

YML

# 断言，路径相匹配的进行路由
predicates:		
	- Host=**.ceshi.com

使用CMD的curl命令测试


带Host测试



不带Host测试



带错误Host测试



7.Method

YML

# 断言，路径相匹配的进行路由
predicates:		
	- Method=GET

8.Path
9.Query
10.Weight

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zoengzihaam.github.io/post/12/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zoengzihaam.github.io/post/11/">
                        参考RoundRobinRule代码模拟负载均衡
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-06-25</time>
                    
                        <a href="https://zoengzihaam.github.io/tag/hR2Q3InCJ/" class="post-tag i-tag
                            i-tag-">
            #spring
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            参考RoundRobinRule代码模拟负载均衡
1.定义一个LoadBalancer接口

获取服务器集群上能够提供服务的机器数量

public interface Loadbalancer {
    /**
     * 获取服务器集群上能够提供服务的机器数量
     * @param serviceInstances
     * @return
     */
    ServiceInstance instances(List&amp;lt;ServiceInstance&amp;gt; serviceInstances);
}

2.实现LoadBalancer接口中的方法

利用自旋锁，创建获取当前服务调用是第几次访问的方法
实现接口中获取提供服务机器数量的方法，模拟负载均衡算法来达到负载调用服务。

/**
 * ClassName: MyLB
 * Description: 参考RoundRobinRule代码模拟负载均衡
 * Author: SUGAR
 * Date: 2020/6/25 16:09
 * Version: 1.0
 **/
@Component
public class MyLB implements Loadbalancer{

    private AtomicInteger atomicInteger = new AtomicInteger(0);

    /**
     * 获取当前服务调用是第几次访问
     * @return
     */
    public final int getAndIncrement(){
        int current;
        int next;

        do {
            current = this.atomicInteger.get();
            next = current &amp;gt;= 2147483647 ? 0 : current + 1;
        }while (!this.atomicInteger.compareAndSet(current,next));
        System.out.println(&amp;quot;*****访问第&amp;quot; + next + &amp;quot;次！*****&amp;quot;);
        return next;
    }

    /**
     * 根据第几次访问，模拟负载均衡算法来达到负载调用服务
     * 负载均衡算法：rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标
     * 每次服务启动后rest接口计数从1开始
     * @param serviceInstances
     * @return
     */
    @Override
    public ServiceInstance instances(List&amp;lt;ServiceInstance&amp;gt; serviceInstances) {

        int index = getAndIncrement() % serviceInstances.size();

        return serviceInstances.get(index);
    }
}

3.取消LoadBalanced注解

取消ApplicationContextConfig中RestTemplate的get方法的LoadBalanced注解，使用自己模拟的负载均衡。

@Configuration
public class ApplicationContextConfig {

    @Bean
//    @LoadBalanced 使用自己模拟的负载均衡的方法
    public RestTemplate getRestTemplate(){
        return new RestTemplate();
    }
}

4.添加服务提供商提供的controller方法

添加一个获取当前服务提供者端口的方法，用来负载均衡。

@GetMapping(value = &amp;quot;/payment/lb&amp;quot;)
public String getPaymentLB() {
    return serverPort;
}

注：这里的方法添加到提供商的controller中。
5.调用者添加controller方法

调用者controller添加调用服务提供商的方法，测试负载均衡

@GetMapping(value = &amp;quot;/consumer/payment/lb&amp;quot;)
public String getPayementLB(){
    List&amp;lt;ServiceInstance&amp;gt; instances = discoveryClient.getInstances(&amp;quot;CLOUD-PAYMENT-SERVICE&amp;quot;);
    //判断服务是否为有效服务
    if(instances == null || instances.size() &amp;lt;= 0){
        return null;
    }

    ServiceInstance serviceInstance = loadbalancer.instances(instances);
    URI uri = serviceInstance.getUri();

    return restTemplate.getForObject(uri + &amp;quot;/payment/lb&amp;quot;,String.class);
}

6.测试

启动对应的服务



查看是否启动成功（模拟提供者集群以及服务器集群）



模拟调用者访问接口




​	根据以上调用，后台也打印出相应的调用信息。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zoengzihaam.github.io/post/11/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zoengzihaam.github.io/post/10/">
                        Docker中 CMD 与 ENTRYPOINT 保留指令的区别
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-06-09</time>
                    
                        <a href="https://zoengzihaam.github.io/tag/bV_DFMXGZ/" class="post-tag i-tag
                            i-tag-other_3">
            #Docker
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
编写Dockerfile时，时常看到最后会看到CMD或者ENTRYPOINT 的保留指令，但是他们的意义都为：指定一个容器启动时要运行的命令，那么它们之间的差异在哪里？

使用curl命令来说明
首先编写两个Dockerfile

使用CMD保留指令。

FROM centos
RUN yum install -y curl
CMD [ &amp;quot;curl&amp;quot;, &amp;quot;-s&amp;quot;, &amp;quot;https://www.baidu.com/&amp;quot; ]

这里 Dockerfile 的名字要求小写，否则会报错invalid argument &amp;quot;cmdCentos&amp;quot; for &amp;quot;-t, --tag&amp;quot; flag: invalid reference format: repository name must be lowercase See &#39;docker build --help&#39;.


使用ENTRYPOINT保留指令。

FROM centos
RUN yum install -y curl
ENTRYPOINT [ &amp;quot;curl&amp;quot;, &amp;quot;-s&amp;quot;, &amp;quot;https://www.baidu.com/&amp;quot; ]


在docker中进行build进行构建一个新的镜像


构建CMD保留指令的Dockerfile。



构建ENTRYPOINT保留指令的Dockerfile。



运行两个镜像进行对比


运行CMD保留指令的镜像。



运行ENTRYPOINT保留指令的镜像。



这个时候我们发现，两个镜像运行起来没有任何区别，但是重点来了！当我们需要对镜像启动时要运行的命令进行增强的时候。
比如我们还想获取指定网站的头信息。


运行增强后的CMD保留指令的镜像。



运行增强后的ENTRYPOINT保留指令的镜像。



总结
由上述的案例，我们不难发现，在执行Dockerfile中，如果使用了CMD保留指令，那么在执行镜像的时候，我们在其启动命令后面添加OPTION选项的时候，将会覆盖Dockerfile中的上一句指令，造成运行失败。例如：
FROM centos
RUN yum install -y curl
CMD [ &amp;quot;curl&amp;quot;, &amp;quot;-s&amp;quot;, &amp;quot;https://www.baidu.com/&amp;quot; ]
CMD -i

如果使用ENTRYPOINT保留指令，那么在执行镜像的时候，我们在其启动命令后面添加OPTION选项的时候，会对运行的命令进行“增强”。例如：
FROM centos
RUN yum install -y curl
ENTRYPOINT [ &amp;quot;curl&amp;quot;, &amp;quot;-s&amp;quot;,&amp;quot;-i&amp;quot;, &amp;quot;https://www.baidu.com/&amp;quot; ]

所以，在实际应用中，是使用CMD还是ENTRYPOINT保留指令，要根据具体的业务要求。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zoengzihaam.github.io/post/10/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zoengzihaam.github.io/post/9/">
                        在VMware Workstation上安装CentOS7的网络问题
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-06-09</time>
                    
                        <a href="https://zoengzihaam.github.io/tag/BMhg_qYrO/" class="post-tag i-tag
                            i-tag-info">
            #Linux
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            配置网络
虚拟机CentOS的网络设置
1. 将网络适配器设置为NAT模式

2. Linux中网络设置
cd /etc/sysconfig/network-scripts/，进入CentOS7的网络配置文件下，找到对应的网卡设置，我这里的网卡是ifcfg-ens32，每个人的网卡名称可能不一样，不用在意。

vim ifcfg-ens32 ，打开指定的网卡配置文件，如果系统没有安装 vim，使用 vi 打开即可。

添加的ip、子网掩码、网关，在VMware Workstation中的虚拟网络编辑器中查看。

选择VMnet8，然后NAT设置


IPADDR：为上方的子网IP，建议IP设置为XXX.XXX.XXX.200~XXX.XXX.XXX.250之间
PREFIXO：为上方子网掩码，255.255.255.0即为24
GATEWAY：为上方网关IP，对应填上即可。
DNS1：8.8.8.8
DNS2：8.8.4.4
这里DNS都设置为谷歌的DNS，正常解析即可，其他DNS也可。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zoengzihaam.github.io/post/9/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zoengzihaam.github.io/post/8/">
                        Redis
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-06-04</time>
                    
                        <a href="https://zoengzihaam.github.io/tag/5K5Gk1gnd/" class="post-tag i-tag
                            i-tag-warning">
            #Redis
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
多能，数据类型丰富，使用Redis，Tair
Redis:REmote DIctionary Server(远程字典服务器)
是完全开源免费的，用C语言编写的，遵守BSD协议，
是一个高性能的(key/value)分布式内存数据库，基于内存运行
并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,
也被人们称为数据结构服务器

下载Redis
https://redis.io/download
对Redis的理解

Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。
KV、Cache、Persistence、...

Redis的概述

3V+3高




3V
3高




海量Volume
高并发


多样Variety
高可扩


实时Velocity
高性能



传统关系型数据库
传统的ACID
1、A (Atomicity) 原子性
原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。
2、C (Consistency) 一致性
一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。
3、I (Isolation) 独立性
所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的
4、D (Durability) 持久性
持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。
非关系型数据库
CAP
C:Consistency（强一致性）
A:Availability（可用性）
P:Partition tolerance（分区容错性）
Redis的安装

Linux版安装



获取Redis的安装包
将安装包放在/usr/local/redis下


解压Redis安装包


tar -zxvf redis-5.0.4.tar.gz


进入Redis目录

cd /usr/local/redis/redis-5.0.4


执行make命令

make

运行make命令时故
意出现的错误解析：
​	安装gcc
yum -y install gcc-c++


执行make install，检验安装

make install

Redis基本使用
更改配置
1.更改redis.conf配置文件
首先备份当前redis.conf文件，修改以下内容。
daemonize yes

启动
安装redis之后，在/usr/local/bin会有redis的启动文件。


执行redis-server /bak/redis/redis.conf，启动redis并使用指定的配置文件。

redis-server /bak/redis/redis.conf


连通测试

执行redis-cli -p 6379来指定端口启动测试。

redis-cli -p 6379


使用ping命令来测试连通，出现PONG即为成功。



可使用ps -ef|grep redis来查看redis的进程。

ps -ef|grep redis


关闭redis

执行redis-cli shutdown。

redis-cli shutdown

Redis可能遇到问题

修改配置文件

protected-mode no # 关闭保护模式
daemonize yes     # 守护进程模式开启
#bind 127.0.0.1   # 绑定IP按需修改
port 6379         # 端口按需修改


运行并检查端口

#启动服务命令
./usr/local/bin/redis-server /bak/redis/redis.conf
#查看6379端口是否占用
netstat -tunpl | grep 6379


开放防火墙端口

#开放6379端口
/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT
#保存配置
/etc/rc.d/init.d/iptables save
#重启服务
/etc/rc.d/init.d/iptables restart
#查看端口是否已经开放
/etc/init.d/iptables status

Redis启动后杂项基础知识讲解
单进程

单进程模型来处理客户端的请求。对读写等事件的响应
是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率


Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，
它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。

默认16个数据库


默认16个数据库，类似数组下表从零开始，初始默认使用零号库。
可以使用select &amp;lt;id&amp;gt;来连接指定数据库id



DBSIZE

Dbsize查看当前数据库的key的数量

DBSIZE



使用keys *可查看当前库中的key

keys *


FLUSHDB

清空当前库

FLUSHDB


FLUSHALL

通杀全部库

FLUSHALL


统一密码管理
索引

Reids索引都是从零开始

默认端口

默认端口是6379

Redis数据类型
Redis的五大数据类型
String（字符串）
String（字符串）
string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。
string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。
string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M
Hash（哈希，类似java里的Map）
Hash（哈希）
Redis hash 是一个键值对集合。
Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。
类似Java里面的Map&amp;lt;String,Object&amp;gt;
List（列表）
List（列表）
Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。
它的底层实际是个链表
Set（集合）
Redis的Set是string类型的无序集合。它是通过HashTable实现实现的。
Zset(sorted set：有序集合)
zset(sorted set：有序集合)
Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
不同的是每个元素都会关联一个double类型的分数。
redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。
哪里去获得redis常见数据类型操作命令

Http://redisdoc.com/





Redis 键(key)

常用




案例

keys *



exists key的名字，判断某个key是否存在。



move key db，移动当前库的key到指定的库中。



expire key，给指定的key设置一个过期时间。



ttl key，查看当前key的过期时间，-1表示永不过期，-2表示已过期。

当key过期的时候，代表当前key的生命周期已经结束，所以在当前库中就不存在这个key。


type key，查看当前的key的类型。



del key，删除当前的key




Redis字符串(String)

常用





单值单value


案例

set key value，设置一个K,V



get key，获取当前key的value值。



append key value，在指定key的value值后添加指定的值。



strlen key，查询当前key的长度。



incr key，对当前的key进行递增。



decr key，对当前的key进行递减。




incrby key num，对当前的key进行指定数字的递增。

decrby key num，对当前的key进行指定数字的递减。

**注意：**一定要是数字才能进行加减。
getrange key start end，获取当前key字符串的指定长度内容。

setrange key index str，设置当前key字符串指定下标开始，设置str内容。

setex key second valuesetex(set with expire)，设置K,V，并设置到期时间。

setnx key value，setnx(set if not exist)，只有当前key不存在的时候，设置key的值。

mset key1 value1 key2 value2 key3 value3，设置多个K,V。

mget key1 key2 key3，获取多个指定key的值。

msetnx key1 value1 key2 value2 key3 value3，设置多个值，当设置key不存在时，设置指定key值，如果一个不存在，则都不设置。

Redis列表(List)

常用





单值多value


案例

lpush key value1 [value2]，将一个或多个值插入到列表头部。




rpush key value1 [value2]，在列表中添加一个或多个值

lrange key start end，获取列表指定范围内的元素

lpop key，移除并获取列表的第一个元素

rpop key，移除并获取列表最后一个元素。

lindex key index，根据下标，查询执行列表中的数据。

llen key，查询指定列表的长度

lrem key count value，移除指定列表指定数量的值。

ltrim key start end，截取指定列表的指定下标内容，然后赋值给这个列表。

rpoplpush source destination，移除列表的最后一个元素，并将该元素添加到另一个列表并返回。

lset key index value，通过索引设置列表元素的值。

linsert key before|after pivot value，在列表的元素前或者后插入元素。

Redis集合(Set)

常用




单值多value


案例

sadd key member1 [member2]，向集合添加一个或多个成员。



smembers key，返回集合中的所有成员



sismember key member，判断 member 元素是否是集合key的成员。



scard key，获取集合的成员数



srem key member1 [member2]，移除集合中一个或多个成员



srandmember key [count]，返回集合中一个或多个随机数。



spop key，移除并返回集合中的一个随机元素



smove key1 key2 member，将member元素从key1集合移动到key2集合。




数学集合类

sdiff key1 [key2]，返回给定所有集合的差集。（在第一个set里面而不在后面任何一个set里面的项）



sinter key1 [key2]，返回给定所有集合的交集。



sunion key1 [key2]，返回所有给定集合的并集。






Redis哈希(Hash)

常用




KV模式不变，但V是一个键值对。


案例

hset key field value，将哈希表key中 的字段field的值设为value。



hget key field，获取存储在哈希表中指定field字段的值。



hmset key field1 value1 [field2 value2]，同时将多个field-value(域-值)对设置到哈希表key中。



hgetall key，获得存储在哈希表中指定key的所有字段和值。



hdel key field，删除存储在哈希表中key 指定字段。



hexists key field，查询存储在哈希表中指定字段是否存在



hkeys key，获取所有哈希表中的字段



hvals keys，获取哈希表中所有的值。



hincrby key field increment，为哈希表key中的指定字段的整数值加上增量increment。



hincrbyfloat key field increment，为哈希表中的指定字段的浮点数值加上增量increment。



hsetnx key field value，只有在字段field不存在时，设置哈希表字段的值。




Redis有序集合Zset(sorted set)

常用





案例

zadd key score1 member1 [score2 member2]，向有序集合添加一个或多个成员，或者更新已存在成员的分数。



zrangebyscore key start end，通过分数返回有序集合指定区间内的成员。



zrangebyscore key (start end，通过返回有序集合指定区间内(带有(，说明不包含)的成员。



zrem key member，根据对应的value值删除有序集合中的成员元素。



zcard key，获得有序列表中的成员数。



zcount key min max，查询在有序列表中指定区间的成员数。



zrank key value，获取指定成员在有序列表中的下标。



zscore key value，获取有序列表中指定成员的值。



zrevrank key values，逆序获得下标值。




解析配置文件redis.conf
1.它在哪


地址。
进入redis目录下，使用pwd命令来查看当前目录。





为什么拷贝出来单独执行？
通常为了配置的安全，放置在原文件配置错误，导致无法正常运行。


2.Units单位

3.INCLUDES包含

和其他配置文件一样，可以通过includes包含，redis.conf可以作为总闸，包含其他。


4.GENERAL通用
daemonize

介绍

A、redis.conf配置文件中daemonize守护线程，默认是NO。
B、daemonize是用来指定redis是否要用守护线程的方式启动。


daemonize 设置yes或者no区别

daemonize:yes:redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。
daemonize:no: 当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。



Pidfile

当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定。

Port

指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字。

Tcp-backlog


文档解释
tcp-backlog
设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。
在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值来达到想要的效果。


Timeout

当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能。

Bind

绑定的主机地址

Tcp-keepalive

单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60。

Loglevel

指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice

Logfile

指定日志文件的路径。

Syslog-enabled

是否把日志输出到syslog中。默认是no。

Syslog-ident

指定syslog里的日志标志。默认是redis。

Syslog-facility

指定syslog设备，值可以是USER或LOCAL0-LOCAL7。默认是LOCAL0。

Databases

设置数据库的数量，默认数量为16，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id。

5.SNAPSHOTTING快照
Save

save 秒钟 写操作次数

RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，
默认
是1分钟内改了1万次，
或5分钟内改了10次，
或15分钟内改了1次。


禁用

如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。


如果想即可备份，使用save命令，可执行立即备份功能。

Stop-writes-on-bgsave-error
如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制。

rdbcompression
rdbcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用
LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能
rdbchecksum
dbfilename
dir
6.REPLICATION复制
7.SECURITY安全

访问密码的查看、设置和取消。


8.LIMITS限制
Maxclients

设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当你
无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自
身内部处理逻辑留一些句柄出来。如果达到了此限制，redis则会拒绝新的连接请求，并且向这
些连接请求方发出“max number of clients reached”以作回应。

Maxmemory


设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，
那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。
但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。


Maxmemory-policy

（1）volatile-lru：使用LRU算法移除key，只对设置了过期时间的键。
（2）allkeys-lru：使用LRU算法移除key。
（3）volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键。
（4）allkeys-random：移除随机的key。
（5）volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key。
（6）noeviction：不进行移除。针对写操作，只是返回错误信息。

Maxmemory-samples

设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，
redis默认会检查这么多个key并选择其中LRU的那个。

9.APPEND ONLY MODE追加
appendonly
appendfilename
Appendfsync


Always：同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好。
Everysec：出厂默认推荐，异步操作，每秒记录   如果一秒内宕机，有数据丢失。
No

No-appendfsync-on-rewrite：重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。
Auto-aof-rewrite-min-size：设置重写的基准值
Auto-aof-rewrite-percentage：设置重写的基准值
Redis的持久化
总体介绍
官网介绍

RDB（Redis DataBase）
官网介绍

是什么：

在指定的时间间隔内将内存中的数据集快照写入磁盘，
也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。
Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到
一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。
整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能
如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方
式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。

Fork

Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）
数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。

Rdb 保存的是dump.rdb文件
配置位置

如何触发RDB快照
配置文件中默认的快照配置



冷拷贝后重新使用
可以cp dump.rdb dump_new.rdb


命令save或者是bgsave

Save：save时只管保存，其它不管，全部阻塞



BGSAVE：Redis会在后台异步进行快照操作，
快照同时还可以响应客户端请求。可以通过lastsave
命令获取最后一次成功执行快照的时间

执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义
如何恢复


将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可


CONFIG GET dir获取目录


优势

适合大规模的数据恢复
对数据完整性和一致性要求不高

劣势

在一定间隔时间做一次备份，所以如果redis意外down掉的话，就
会丢失最后一次快照后的所有修改
Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑

如何停止

动态所有停止RDB保存规则的方法：redis-cli config set save &amp;quot;&amp;quot;

小总结

AOF（Append Only File）
官网介绍

是什么：

以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，
只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

Aof保存的是appendonly.aof文件
配置位置

AOF启动/修复/恢复
正常恢复

启动：设置Yes
修改默认的appendonly no，改为yes
将有数据的aof文件复制一份保存到对应目录(config get dir)。
恢复：重启redis然后重新加载。

异常恢复

启动：设置Yes
修改默认的appendonly no，改为yes。
备份被写坏的AOF文件
修复：Redis-check-aof --fix进行修复
恢复：重启redis然后重新加载

Rewrite

是什么：

AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,
当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，
只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof

重写原理
AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，
遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，
而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。
触发机制
Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。
优势
每修改同步：
appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好。
每秒同步：
appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失
不同步：
appendfsync no   从不同步。
劣势

相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb。
Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同。

小总结

总结(Which one)
官网建议



RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。


AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些
命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.
Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。


只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式。


同时开启两种持久化方式。

在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,
因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？
作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，
快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。



性能建议。


因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。
如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。
如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构。




Redis的事务
是什么

可以一次执行多个命令，本质是一组命令的集合。一个事务中的
所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞。


官网


能干嘛

一个队列中，一次性、顺序性、排他性的执行一系列命令。

怎么玩

常用命令

Case1：正常执行

Case2：放弃事务

Case3：全体连坐

Case4：冤头债主

Case5：watch监控


悲观锁/乐观锁/CAS(Check And Set)


悲观锁
悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。


乐观锁
乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，
乐观锁策略:提交版本必须大于记录当前版本才能执行更新。


CAS




初始化信用卡可用余额和欠额



无加塞篡改，先监控再开启multi，保证两笔金额变动在同一个事务内。



有加塞篡改。



unwatch



一旦执行了exec之前加的监控锁都会被取消掉了


小结

Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变，
比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行。
通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，
EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。



3阶段
开启：
以MULTI开始一个事务。
入队：
将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面
执行：
由EXEC命令触发事务
3特性
单独的隔离操作：
事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
没有隔离级别的概念：
队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，
也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题
不保证原子性：
redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚
Redis的发布订阅
是什么


进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。


订阅/发布消息图



命令

案例
先订阅后发布后才能收到消息，


可以一次性订阅多个，SUBSCRIBE c1 c2 c3



消息发布，PUBLISH c2 hello-redis



订阅多个，通配符*， PSUBSCRIBE new*




收取消息， PUBLISH new1 redis2015。


Redis的复制(Master/Slave)
是什么
官网

行话：
也就是我们所说的主从复制，主机数据更新后根据配置和策略，
自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主
能干嘛

读写分离
容灾恢复

怎么玩


配从(库)不配主(库)


从库配置：slaveof 主库IP 主库端口

每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件
Info replication



修改配置文件细节操作


拷贝多个redis.conf文件



开启daemonize yes



Pid文件名字


指定端口


Log文件名字



Dump.rdb名字





常用3招


一主二仆


Init



一个Master两个Slave



日志查看


主机日志



备机日志



info replication





主从问题演示


切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的123是否也可以复制


从机是否可以写？set可否？


主机shutdown后情况如何？从机是上位还是原地待命


主机又回来了后，主机新增记录，从机还能否顺利复制？


其中一台从机down后情况如何？依照原有它能跟上大部队吗？






薪火相传

上一个Slave可以是下一个slave的Master，Slave同样可以接收其他
slaves的连接和同步请求，那么该slave作为了链条中下一个的master,
可以有效减轻master的写压力
中途变更转向:会清除之前的数据，重新建立拷贝最新的
Slaveof 新主库IP 新主库端口



反客为主


SLAVEOF no one
使当前数据库停止与其他数据库的同步，转成主数据库。






复制原理

Slave启动成功连接到master后会发送一个sync命令
Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，
在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步
全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。
增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步
但是只要是重新连接master,一次完全同步（全量复制)将被自动执行

哨兵模式(sentinel)

是什么


反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库



怎么玩(使用步骤)


调整结构，6379带着80、81


自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错


配置哨兵,填写内容

sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1



上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机



启动哨兵


Redis-sentinel /myredis/sentinel.conf
上述目录依照各自的实际情况配置，可能目录不同



正常主从演示


原有的master挂了



投票新选



重新主从继续开工,info replication查查看



问题：如果之前的master重启回来，会不会双master冲突？





一组sentinel能同时监控多个Master


复制的缺点


复制延时
由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。



                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zoengzihaam.github.io/post/8/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
    <div class="pagination-container">
        
                
                    <a href="https://zoengzihaam.github.io/page/2" class="page-btn btn">下一页</a>
                    
    </div>
    
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://zoengzihaam.github.io/images/avatar.png?v=1610626506137)">
        </div>
        <h1 class="id_card-title">
            卷毛
        </h1>
        <h2 class="id_card-description">
            没有撤退可言。
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://zoengzihaam.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>